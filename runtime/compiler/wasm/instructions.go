// Code generated by utils/version. DO NOT EDIT.
/*
 * Cadence - The resource-oriented smart contract programming language
 *
 * Copyright 2019-2022 Dapper Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//go:generate go run ./gen/main.go
//go:generate go fmt $GOFILE

package wasm

import (
	"io"
)

// InstructionUnreachable is the 'unreachable' instruction
//
type InstructionUnreachable struct{}

func (InstructionUnreachable) isInstruction() {}

func (i InstructionUnreachable) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeUnreachable)
	if err != nil {
		return err
	}

	return nil
}

// InstructionNop is the 'nop' instruction
//
type InstructionNop struct{}

func (InstructionNop) isInstruction() {}

func (i InstructionNop) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeNop)
	if err != nil {
		return err
	}

	return nil
}

// InstructionBlock is the 'block' instruction
//
type InstructionBlock struct {
	Block Block
}

func (InstructionBlock) isInstruction() {}

func (i InstructionBlock) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeBlock)
	if err != nil {
		return err
	}

	block := i.Block
	err = w.writeBlockInstructionArgument(block, false)
	if err != nil {
		return err
	}

	return nil
}

// InstructionLoop is the 'loop' instruction
//
type InstructionLoop struct {
	Block Block
}

func (InstructionLoop) isInstruction() {}

func (i InstructionLoop) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeLoop)
	if err != nil {
		return err
	}

	block := i.Block
	err = w.writeBlockInstructionArgument(block, false)
	if err != nil {
		return err
	}

	return nil
}

// InstructionIf is the 'if' instruction
//
type InstructionIf struct {
	Block Block
}

func (InstructionIf) isInstruction() {}

func (i InstructionIf) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeIf)
	if err != nil {
		return err
	}

	block := i.Block
	err = w.writeBlockInstructionArgument(block, true)
	if err != nil {
		return err
	}

	return nil
}

// InstructionEnd is the 'end' instruction
//
type InstructionEnd struct{}

func (InstructionEnd) isInstruction() {}

func (i InstructionEnd) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeEnd)
	if err != nil {
		return err
	}

	return nil
}

// InstructionBr is the 'br' instruction
//
type InstructionBr struct {
	LabelIndex uint32
}

func (InstructionBr) isInstruction() {}

func (i InstructionBr) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeBr)
	if err != nil {
		return err
	}

	labelIndex := i.LabelIndex
	err = w.buf.writeUint32LEB128(labelIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionBrIf is the 'br_if' instruction
//
type InstructionBrIf struct {
	LabelIndex uint32
}

func (InstructionBrIf) isInstruction() {}

func (i InstructionBrIf) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeBrIf)
	if err != nil {
		return err
	}

	labelIndex := i.LabelIndex
	err = w.buf.writeUint32LEB128(labelIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionBrTable is the 'br_table' instruction
//
type InstructionBrTable struct {
	LabelIndices      []uint32
	DefaultLabelIndex uint32
}

func (InstructionBrTable) isInstruction() {}

func (i InstructionBrTable) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeBrTable)
	if err != nil {
		return err
	}

	labelIndices := i.LabelIndices
	labelIndicesCount := len(labelIndices)
	err = w.buf.writeUint32LEB128(uint32(labelIndicesCount))
	if err != nil {
		return err
	}

	for i := 0; i < labelIndicesCount; i++ {
		labelIndicesElement := labelIndices[i]
		err = w.buf.writeUint32LEB128(labelIndicesElement)
		if err != nil {
			return err
		}
	}

	defaultLabelIndex := i.DefaultLabelIndex
	err = w.buf.writeUint32LEB128(defaultLabelIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionReturn is the 'return' instruction
//
type InstructionReturn struct{}

func (InstructionReturn) isInstruction() {}

func (i InstructionReturn) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeReturn)
	if err != nil {
		return err
	}

	return nil
}

// InstructionCall is the 'call' instruction
//
type InstructionCall struct {
	FuncIndex uint32
}

func (InstructionCall) isInstruction() {}

func (i InstructionCall) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeCall)
	if err != nil {
		return err
	}

	funcIndex := i.FuncIndex
	err = w.buf.writeUint32LEB128(funcIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionCallIndirect is the 'call_indirect' instruction
//
type InstructionCallIndirect struct {
	TypeIndex  uint32
	TableIndex uint32
}

func (InstructionCallIndirect) isInstruction() {}

func (i InstructionCallIndirect) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeCallIndirect)
	if err != nil {
		return err
	}

	typeIndex := i.TypeIndex
	err = w.buf.writeUint32LEB128(typeIndex)
	if err != nil {
		return err
	}

	tableIndex := i.TableIndex
	err = w.buf.writeUint32LEB128(tableIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionRefNull is the 'ref.null' instruction
//
type InstructionRefNull struct {
	TypeIndex uint32
}

func (InstructionRefNull) isInstruction() {}

func (i InstructionRefNull) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeRefNull)
	if err != nil {
		return err
	}

	typeIndex := i.TypeIndex
	err = w.buf.writeUint32LEB128(typeIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionRefIsNull is the 'ref.is_null' instruction
//
type InstructionRefIsNull struct{}

func (InstructionRefIsNull) isInstruction() {}

func (i InstructionRefIsNull) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeRefIsNull)
	if err != nil {
		return err
	}

	return nil
}

// InstructionRefFunc is the 'ref.func' instruction
//
type InstructionRefFunc struct {
	FuncIndex uint32
}

func (InstructionRefFunc) isInstruction() {}

func (i InstructionRefFunc) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeRefFunc)
	if err != nil {
		return err
	}

	funcIndex := i.FuncIndex
	err = w.buf.writeUint32LEB128(funcIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionDrop is the 'drop' instruction
//
type InstructionDrop struct{}

func (InstructionDrop) isInstruction() {}

func (i InstructionDrop) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeDrop)
	if err != nil {
		return err
	}

	return nil
}

// InstructionSelect is the 'select' instruction
//
type InstructionSelect struct{}

func (InstructionSelect) isInstruction() {}

func (i InstructionSelect) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeSelect)
	if err != nil {
		return err
	}

	return nil
}

// InstructionLocalGet is the 'local.get' instruction
//
type InstructionLocalGet struct {
	LocalIndex uint32
}

func (InstructionLocalGet) isInstruction() {}

func (i InstructionLocalGet) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeLocalGet)
	if err != nil {
		return err
	}

	localIndex := i.LocalIndex
	err = w.buf.writeUint32LEB128(localIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionLocalSet is the 'local.set' instruction
//
type InstructionLocalSet struct {
	LocalIndex uint32
}

func (InstructionLocalSet) isInstruction() {}

func (i InstructionLocalSet) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeLocalSet)
	if err != nil {
		return err
	}

	localIndex := i.LocalIndex
	err = w.buf.writeUint32LEB128(localIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionLocalTee is the 'local.tee' instruction
//
type InstructionLocalTee struct {
	LocalIndex uint32
}

func (InstructionLocalTee) isInstruction() {}

func (i InstructionLocalTee) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeLocalTee)
	if err != nil {
		return err
	}

	localIndex := i.LocalIndex
	err = w.buf.writeUint32LEB128(localIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionGlobalGet is the 'global.get' instruction
//
type InstructionGlobalGet struct {
	GlobalIndex uint32
}

func (InstructionGlobalGet) isInstruction() {}

func (i InstructionGlobalGet) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeGlobalGet)
	if err != nil {
		return err
	}

	globalIndex := i.GlobalIndex
	err = w.buf.writeUint32LEB128(globalIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionGlobalSet is the 'global.set' instruction
//
type InstructionGlobalSet struct {
	GlobalIndex uint32
}

func (InstructionGlobalSet) isInstruction() {}

func (i InstructionGlobalSet) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeGlobalSet)
	if err != nil {
		return err
	}

	globalIndex := i.GlobalIndex
	err = w.buf.writeUint32LEB128(globalIndex)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Const is the 'i32.const' instruction
//
type InstructionI32Const struct {
	Value int32
}

func (InstructionI32Const) isInstruction() {}

func (i InstructionI32Const) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Const)
	if err != nil {
		return err
	}

	value := i.Value
	err = w.buf.writeInt32LEB128(value)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Const is the 'i64.const' instruction
//
type InstructionI64Const struct {
	Value int64
}

func (InstructionI64Const) isInstruction() {}

func (i InstructionI64Const) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Const)
	if err != nil {
		return err
	}

	value := i.Value
	err = w.buf.writeInt64LEB128(value)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Eqz is the 'i32.eqz' instruction
//
type InstructionI32Eqz struct{}

func (InstructionI32Eqz) isInstruction() {}

func (i InstructionI32Eqz) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Eqz)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Eq is the 'i32.eq' instruction
//
type InstructionI32Eq struct{}

func (InstructionI32Eq) isInstruction() {}

func (i InstructionI32Eq) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Eq)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Ne is the 'i32.ne' instruction
//
type InstructionI32Ne struct{}

func (InstructionI32Ne) isInstruction() {}

func (i InstructionI32Ne) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Ne)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32LtS is the 'i32.lt_s' instruction
//
type InstructionI32LtS struct{}

func (InstructionI32LtS) isInstruction() {}

func (i InstructionI32LtS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32LtS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32LtU is the 'i32.lt_u' instruction
//
type InstructionI32LtU struct{}

func (InstructionI32LtU) isInstruction() {}

func (i InstructionI32LtU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32LtU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32GtS is the 'i32.gt_s' instruction
//
type InstructionI32GtS struct{}

func (InstructionI32GtS) isInstruction() {}

func (i InstructionI32GtS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32GtS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32GtU is the 'i32.gt_u' instruction
//
type InstructionI32GtU struct{}

func (InstructionI32GtU) isInstruction() {}

func (i InstructionI32GtU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32GtU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32LeS is the 'i32.le_s' instruction
//
type InstructionI32LeS struct{}

func (InstructionI32LeS) isInstruction() {}

func (i InstructionI32LeS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32LeS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32LeU is the 'i32.le_u' instruction
//
type InstructionI32LeU struct{}

func (InstructionI32LeU) isInstruction() {}

func (i InstructionI32LeU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32LeU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32GeS is the 'i32.ge_s' instruction
//
type InstructionI32GeS struct{}

func (InstructionI32GeS) isInstruction() {}

func (i InstructionI32GeS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32GeS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32GeU is the 'i32.ge_u' instruction
//
type InstructionI32GeU struct{}

func (InstructionI32GeU) isInstruction() {}

func (i InstructionI32GeU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32GeU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Eqz is the 'i64.eqz' instruction
//
type InstructionI64Eqz struct{}

func (InstructionI64Eqz) isInstruction() {}

func (i InstructionI64Eqz) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Eqz)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Eq is the 'i64.eq' instruction
//
type InstructionI64Eq struct{}

func (InstructionI64Eq) isInstruction() {}

func (i InstructionI64Eq) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Eq)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Ne is the 'i64.ne' instruction
//
type InstructionI64Ne struct{}

func (InstructionI64Ne) isInstruction() {}

func (i InstructionI64Ne) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Ne)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64LtS is the 'i64.lt_s' instruction
//
type InstructionI64LtS struct{}

func (InstructionI64LtS) isInstruction() {}

func (i InstructionI64LtS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64LtS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64LtU is the 'i64.lt_u' instruction
//
type InstructionI64LtU struct{}

func (InstructionI64LtU) isInstruction() {}

func (i InstructionI64LtU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64LtU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64GtS is the 'i64.gt_s' instruction
//
type InstructionI64GtS struct{}

func (InstructionI64GtS) isInstruction() {}

func (i InstructionI64GtS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64GtS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64GtU is the 'i64.gt_u' instruction
//
type InstructionI64GtU struct{}

func (InstructionI64GtU) isInstruction() {}

func (i InstructionI64GtU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64GtU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64LeS is the 'i64.le_s' instruction
//
type InstructionI64LeS struct{}

func (InstructionI64LeS) isInstruction() {}

func (i InstructionI64LeS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64LeS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64LeU is the 'i64.le_u' instruction
//
type InstructionI64LeU struct{}

func (InstructionI64LeU) isInstruction() {}

func (i InstructionI64LeU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64LeU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64GeS is the 'i64.ge_s' instruction
//
type InstructionI64GeS struct{}

func (InstructionI64GeS) isInstruction() {}

func (i InstructionI64GeS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64GeS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64GeU is the 'i64.ge_u' instruction
//
type InstructionI64GeU struct{}

func (InstructionI64GeU) isInstruction() {}

func (i InstructionI64GeU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64GeU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Clz is the 'i32.clz' instruction
//
type InstructionI32Clz struct{}

func (InstructionI32Clz) isInstruction() {}

func (i InstructionI32Clz) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Clz)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Ctz is the 'i32.ctz' instruction
//
type InstructionI32Ctz struct{}

func (InstructionI32Ctz) isInstruction() {}

func (i InstructionI32Ctz) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Ctz)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Popcnt is the 'i32.popcnt' instruction
//
type InstructionI32Popcnt struct{}

func (InstructionI32Popcnt) isInstruction() {}

func (i InstructionI32Popcnt) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Popcnt)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Add is the 'i32.add' instruction
//
type InstructionI32Add struct{}

func (InstructionI32Add) isInstruction() {}

func (i InstructionI32Add) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Add)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Sub is the 'i32.sub' instruction
//
type InstructionI32Sub struct{}

func (InstructionI32Sub) isInstruction() {}

func (i InstructionI32Sub) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Sub)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Mul is the 'i32.mul' instruction
//
type InstructionI32Mul struct{}

func (InstructionI32Mul) isInstruction() {}

func (i InstructionI32Mul) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Mul)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32DivS is the 'i32.div_s' instruction
//
type InstructionI32DivS struct{}

func (InstructionI32DivS) isInstruction() {}

func (i InstructionI32DivS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32DivS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32DivU is the 'i32.div_u' instruction
//
type InstructionI32DivU struct{}

func (InstructionI32DivU) isInstruction() {}

func (i InstructionI32DivU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32DivU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32RemS is the 'i32.rem_s' instruction
//
type InstructionI32RemS struct{}

func (InstructionI32RemS) isInstruction() {}

func (i InstructionI32RemS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32RemS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32RemU is the 'i32.rem_u' instruction
//
type InstructionI32RemU struct{}

func (InstructionI32RemU) isInstruction() {}

func (i InstructionI32RemU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32RemU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32And is the 'i32.and' instruction
//
type InstructionI32And struct{}

func (InstructionI32And) isInstruction() {}

func (i InstructionI32And) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32And)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Or is the 'i32.or' instruction
//
type InstructionI32Or struct{}

func (InstructionI32Or) isInstruction() {}

func (i InstructionI32Or) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Or)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Xor is the 'i32.xor' instruction
//
type InstructionI32Xor struct{}

func (InstructionI32Xor) isInstruction() {}

func (i InstructionI32Xor) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Xor)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Shl is the 'i32.shl' instruction
//
type InstructionI32Shl struct{}

func (InstructionI32Shl) isInstruction() {}

func (i InstructionI32Shl) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Shl)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32ShrS is the 'i32.shr_s' instruction
//
type InstructionI32ShrS struct{}

func (InstructionI32ShrS) isInstruction() {}

func (i InstructionI32ShrS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32ShrS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32ShrU is the 'i32.shr_u' instruction
//
type InstructionI32ShrU struct{}

func (InstructionI32ShrU) isInstruction() {}

func (i InstructionI32ShrU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32ShrU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Rotl is the 'i32.rotl' instruction
//
type InstructionI32Rotl struct{}

func (InstructionI32Rotl) isInstruction() {}

func (i InstructionI32Rotl) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Rotl)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32Rotr is the 'i32.rotr' instruction
//
type InstructionI32Rotr struct{}

func (InstructionI32Rotr) isInstruction() {}

func (i InstructionI32Rotr) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32Rotr)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Clz is the 'i64.clz' instruction
//
type InstructionI64Clz struct{}

func (InstructionI64Clz) isInstruction() {}

func (i InstructionI64Clz) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Clz)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Ctz is the 'i64.ctz' instruction
//
type InstructionI64Ctz struct{}

func (InstructionI64Ctz) isInstruction() {}

func (i InstructionI64Ctz) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Ctz)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Popcnt is the 'i64.popcnt' instruction
//
type InstructionI64Popcnt struct{}

func (InstructionI64Popcnt) isInstruction() {}

func (i InstructionI64Popcnt) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Popcnt)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Add is the 'i64.add' instruction
//
type InstructionI64Add struct{}

func (InstructionI64Add) isInstruction() {}

func (i InstructionI64Add) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Add)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Sub is the 'i64.sub' instruction
//
type InstructionI64Sub struct{}

func (InstructionI64Sub) isInstruction() {}

func (i InstructionI64Sub) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Sub)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Mul is the 'i64.mul' instruction
//
type InstructionI64Mul struct{}

func (InstructionI64Mul) isInstruction() {}

func (i InstructionI64Mul) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Mul)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64DivS is the 'i64.div_s' instruction
//
type InstructionI64DivS struct{}

func (InstructionI64DivS) isInstruction() {}

func (i InstructionI64DivS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64DivS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64DivU is the 'i64.div_u' instruction
//
type InstructionI64DivU struct{}

func (InstructionI64DivU) isInstruction() {}

func (i InstructionI64DivU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64DivU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64RemS is the 'i64.rem_s' instruction
//
type InstructionI64RemS struct{}

func (InstructionI64RemS) isInstruction() {}

func (i InstructionI64RemS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64RemS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64RemU is the 'i64.rem_u' instruction
//
type InstructionI64RemU struct{}

func (InstructionI64RemU) isInstruction() {}

func (i InstructionI64RemU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64RemU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64And is the 'i64.and' instruction
//
type InstructionI64And struct{}

func (InstructionI64And) isInstruction() {}

func (i InstructionI64And) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64And)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Or is the 'i64.or' instruction
//
type InstructionI64Or struct{}

func (InstructionI64Or) isInstruction() {}

func (i InstructionI64Or) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Or)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Xor is the 'i64.xor' instruction
//
type InstructionI64Xor struct{}

func (InstructionI64Xor) isInstruction() {}

func (i InstructionI64Xor) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Xor)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Shl is the 'i64.shl' instruction
//
type InstructionI64Shl struct{}

func (InstructionI64Shl) isInstruction() {}

func (i InstructionI64Shl) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Shl)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64ShrS is the 'i64.shr_s' instruction
//
type InstructionI64ShrS struct{}

func (InstructionI64ShrS) isInstruction() {}

func (i InstructionI64ShrS) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64ShrS)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64ShrU is the 'i64.shr_u' instruction
//
type InstructionI64ShrU struct{}

func (InstructionI64ShrU) isInstruction() {}

func (i InstructionI64ShrU) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64ShrU)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Rotl is the 'i64.rotl' instruction
//
type InstructionI64Rotl struct{}

func (InstructionI64Rotl) isInstruction() {}

func (i InstructionI64Rotl) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Rotl)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64Rotr is the 'i64.rotr' instruction
//
type InstructionI64Rotr struct{}

func (InstructionI64Rotr) isInstruction() {}

func (i InstructionI64Rotr) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64Rotr)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI32WrapI64 is the 'i32.wrap_i64' instruction
//
type InstructionI32WrapI64 struct{}

func (InstructionI32WrapI64) isInstruction() {}

func (i InstructionI32WrapI64) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI32WrapI64)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64ExtendI32S is the 'i64.extend_i32_s' instruction
//
type InstructionI64ExtendI32S struct{}

func (InstructionI64ExtendI32S) isInstruction() {}

func (i InstructionI64ExtendI32S) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64ExtendI32S)
	if err != nil {
		return err
	}

	return nil
}

// InstructionI64ExtendI32U is the 'i64.extend_i32_u' instruction
//
type InstructionI64ExtendI32U struct{}

func (InstructionI64ExtendI32U) isInstruction() {}

func (i InstructionI64ExtendI32U) write(w *WASMWriter) error {
	err := w.writeOpcode(opcodeI64ExtendI32U)
	if err != nil {
		return err
	}

	return nil
}

const (
	// opcodeUnreachable is the opcode for the 'unreachable' instruction
	opcodeUnreachable opcode = 0x0
	// opcodeNop is the opcode for the 'nop' instruction
	opcodeNop opcode = 0x1
	// opcodeBlock is the opcode for the 'block' instruction
	opcodeBlock opcode = 0x2
	// opcodeLoop is the opcode for the 'loop' instruction
	opcodeLoop opcode = 0x3
	// opcodeIf is the opcode for the 'if' instruction
	opcodeIf opcode = 0x4
	// opcodeEnd is the opcode for the 'end' instruction
	opcodeEnd opcode = 0xb
	// opcodeBr is the opcode for the 'br' instruction
	opcodeBr opcode = 0xc
	// opcodeBrIf is the opcode for the 'br_if' instruction
	opcodeBrIf opcode = 0xd
	// opcodeBrTable is the opcode for the 'br_table' instruction
	opcodeBrTable opcode = 0xe
	// opcodeReturn is the opcode for the 'return' instruction
	opcodeReturn opcode = 0xf
	// opcodeCall is the opcode for the 'call' instruction
	opcodeCall opcode = 0x10
	// opcodeCallIndirect is the opcode for the 'call_indirect' instruction
	opcodeCallIndirect opcode = 0x11
	// opcodeRefNull is the opcode for the 'ref.null' instruction
	opcodeRefNull opcode = 0xd0
	// opcodeRefIsNull is the opcode for the 'ref.is_null' instruction
	opcodeRefIsNull opcode = 0xd1
	// opcodeRefFunc is the opcode for the 'ref.func' instruction
	opcodeRefFunc opcode = 0xd2
	// opcodeDrop is the opcode for the 'drop' instruction
	opcodeDrop opcode = 0x1a
	// opcodeSelect is the opcode for the 'select' instruction
	opcodeSelect opcode = 0x1b
	// opcodeLocalGet is the opcode for the 'local.get' instruction
	opcodeLocalGet opcode = 0x20
	// opcodeLocalSet is the opcode for the 'local.set' instruction
	opcodeLocalSet opcode = 0x21
	// opcodeLocalTee is the opcode for the 'local.tee' instruction
	opcodeLocalTee opcode = 0x22
	// opcodeGlobalGet is the opcode for the 'global.get' instruction
	opcodeGlobalGet opcode = 0x23
	// opcodeGlobalSet is the opcode for the 'global.set' instruction
	opcodeGlobalSet opcode = 0x24
	// opcodeI32Const is the opcode for the 'i32.const' instruction
	opcodeI32Const opcode = 0x41
	// opcodeI64Const is the opcode for the 'i64.const' instruction
	opcodeI64Const opcode = 0x42
	// opcodeI32Eqz is the opcode for the 'i32.eqz' instruction
	opcodeI32Eqz opcode = 0x45
	// opcodeI32Eq is the opcode for the 'i32.eq' instruction
	opcodeI32Eq opcode = 0x46
	// opcodeI32Ne is the opcode for the 'i32.ne' instruction
	opcodeI32Ne opcode = 0x47
	// opcodeI32LtS is the opcode for the 'i32.lt_s' instruction
	opcodeI32LtS opcode = 0x48
	// opcodeI32LtU is the opcode for the 'i32.lt_u' instruction
	opcodeI32LtU opcode = 0x49
	// opcodeI32GtS is the opcode for the 'i32.gt_s' instruction
	opcodeI32GtS opcode = 0x4a
	// opcodeI32GtU is the opcode for the 'i32.gt_u' instruction
	opcodeI32GtU opcode = 0x4b
	// opcodeI32LeS is the opcode for the 'i32.le_s' instruction
	opcodeI32LeS opcode = 0x4c
	// opcodeI32LeU is the opcode for the 'i32.le_u' instruction
	opcodeI32LeU opcode = 0x4d
	// opcodeI32GeS is the opcode for the 'i32.ge_s' instruction
	opcodeI32GeS opcode = 0x4e
	// opcodeI32GeU is the opcode for the 'i32.ge_u' instruction
	opcodeI32GeU opcode = 0x4f
	// opcodeI64Eqz is the opcode for the 'i64.eqz' instruction
	opcodeI64Eqz opcode = 0x50
	// opcodeI64Eq is the opcode for the 'i64.eq' instruction
	opcodeI64Eq opcode = 0x51
	// opcodeI64Ne is the opcode for the 'i64.ne' instruction
	opcodeI64Ne opcode = 0x52
	// opcodeI64LtS is the opcode for the 'i64.lt_s' instruction
	opcodeI64LtS opcode = 0x53
	// opcodeI64LtU is the opcode for the 'i64.lt_u' instruction
	opcodeI64LtU opcode = 0x54
	// opcodeI64GtS is the opcode for the 'i64.gt_s' instruction
	opcodeI64GtS opcode = 0x55
	// opcodeI64GtU is the opcode for the 'i64.gt_u' instruction
	opcodeI64GtU opcode = 0x56
	// opcodeI64LeS is the opcode for the 'i64.le_s' instruction
	opcodeI64LeS opcode = 0x57
	// opcodeI64LeU is the opcode for the 'i64.le_u' instruction
	opcodeI64LeU opcode = 0x58
	// opcodeI64GeS is the opcode for the 'i64.ge_s' instruction
	opcodeI64GeS opcode = 0x59
	// opcodeI64GeU is the opcode for the 'i64.ge_u' instruction
	opcodeI64GeU opcode = 0x5a
	// opcodeI32Clz is the opcode for the 'i32.clz' instruction
	opcodeI32Clz opcode = 0x67
	// opcodeI32Ctz is the opcode for the 'i32.ctz' instruction
	opcodeI32Ctz opcode = 0x68
	// opcodeI32Popcnt is the opcode for the 'i32.popcnt' instruction
	opcodeI32Popcnt opcode = 0x69
	// opcodeI32Add is the opcode for the 'i32.add' instruction
	opcodeI32Add opcode = 0x6a
	// opcodeI32Sub is the opcode for the 'i32.sub' instruction
	opcodeI32Sub opcode = 0x6b
	// opcodeI32Mul is the opcode for the 'i32.mul' instruction
	opcodeI32Mul opcode = 0x6c
	// opcodeI32DivS is the opcode for the 'i32.div_s' instruction
	opcodeI32DivS opcode = 0x6d
	// opcodeI32DivU is the opcode for the 'i32.div_u' instruction
	opcodeI32DivU opcode = 0x6e
	// opcodeI32RemS is the opcode for the 'i32.rem_s' instruction
	opcodeI32RemS opcode = 0x6f
	// opcodeI32RemU is the opcode for the 'i32.rem_u' instruction
	opcodeI32RemU opcode = 0x70
	// opcodeI32And is the opcode for the 'i32.and' instruction
	opcodeI32And opcode = 0x71
	// opcodeI32Or is the opcode for the 'i32.or' instruction
	opcodeI32Or opcode = 0x72
	// opcodeI32Xor is the opcode for the 'i32.xor' instruction
	opcodeI32Xor opcode = 0x73
	// opcodeI32Shl is the opcode for the 'i32.shl' instruction
	opcodeI32Shl opcode = 0x74
	// opcodeI32ShrS is the opcode for the 'i32.shr_s' instruction
	opcodeI32ShrS opcode = 0x75
	// opcodeI32ShrU is the opcode for the 'i32.shr_u' instruction
	opcodeI32ShrU opcode = 0x76
	// opcodeI32Rotl is the opcode for the 'i32.rotl' instruction
	opcodeI32Rotl opcode = 0x77
	// opcodeI32Rotr is the opcode for the 'i32.rotr' instruction
	opcodeI32Rotr opcode = 0x78
	// opcodeI64Clz is the opcode for the 'i64.clz' instruction
	opcodeI64Clz opcode = 0x79
	// opcodeI64Ctz is the opcode for the 'i64.ctz' instruction
	opcodeI64Ctz opcode = 0x7a
	// opcodeI64Popcnt is the opcode for the 'i64.popcnt' instruction
	opcodeI64Popcnt opcode = 0x7b
	// opcodeI64Add is the opcode for the 'i64.add' instruction
	opcodeI64Add opcode = 0x7c
	// opcodeI64Sub is the opcode for the 'i64.sub' instruction
	opcodeI64Sub opcode = 0x7d
	// opcodeI64Mul is the opcode for the 'i64.mul' instruction
	opcodeI64Mul opcode = 0x7e
	// opcodeI64DivS is the opcode for the 'i64.div_s' instruction
	opcodeI64DivS opcode = 0x7f
	// opcodeI64DivU is the opcode for the 'i64.div_u' instruction
	opcodeI64DivU opcode = 0x80
	// opcodeI64RemS is the opcode for the 'i64.rem_s' instruction
	opcodeI64RemS opcode = 0x81
	// opcodeI64RemU is the opcode for the 'i64.rem_u' instruction
	opcodeI64RemU opcode = 0x82
	// opcodeI64And is the opcode for the 'i64.and' instruction
	opcodeI64And opcode = 0x83
	// opcodeI64Or is the opcode for the 'i64.or' instruction
	opcodeI64Or opcode = 0x84
	// opcodeI64Xor is the opcode for the 'i64.xor' instruction
	opcodeI64Xor opcode = 0x85
	// opcodeI64Shl is the opcode for the 'i64.shl' instruction
	opcodeI64Shl opcode = 0x86
	// opcodeI64ShrS is the opcode for the 'i64.shr_s' instruction
	opcodeI64ShrS opcode = 0x87
	// opcodeI64ShrU is the opcode for the 'i64.shr_u' instruction
	opcodeI64ShrU opcode = 0x88
	// opcodeI64Rotl is the opcode for the 'i64.rotl' instruction
	opcodeI64Rotl opcode = 0x89
	// opcodeI64Rotr is the opcode for the 'i64.rotr' instruction
	opcodeI64Rotr opcode = 0x8a
	// opcodeI32WrapI64 is the opcode for the 'i32.wrap_i64' instruction
	opcodeI32WrapI64 opcode = 0xa7
	// opcodeI64ExtendI32S is the opcode for the 'i64.extend_i32_s' instruction
	opcodeI64ExtendI32S opcode = 0xac
	// opcodeI64ExtendI32U is the opcode for the 'i64.extend_i32_u' instruction
	opcodeI64ExtendI32U opcode = 0xad
)

// readInstruction reads an instruction in the WASM binary
//
func (r *WASMReader) readInstruction() (Instruction, error) {
	opcodeOffset := r.buf.offset
	b, err := r.buf.ReadByte()

	c := opcode(b)

	if err != nil {
		if err == io.EOF {
			return nil, MissingEndInstructionError{
				Offset: int(opcodeOffset),
			}
		} else {
			return nil, InvalidOpcodeError{
				Offset:    int(opcodeOffset),
				Opcode:    c,
				ReadError: err,
			}
		}
	}

	switch c {
	case opcodeBlock:
		block, err := r.readBlockInstructionArgument(false)
		if err != nil {
			return nil, err
		}

		return InstructionBlock{
			Block: block,
		}, nil

	case opcodeBr:
		labelIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionBr{
			LabelIndex: labelIndex,
		}, nil

	case opcodeBrIf:
		labelIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionBrIf{
			LabelIndex: labelIndex,
		}, nil

	case opcodeBrTable:
		labelIndicesCountOffset := r.buf.offset
		labelIndicesCount, err := r.buf.readUint32LEB128()
		if err != nil {
			return nil, InvalidInstructionVectorArgumentCountError{
				Offset:    int(labelIndicesCountOffset),
				ReadError: err,
			}
		}

		labelIndices := make([]uint32, labelIndicesCount)

		for i := uint32(0); i < labelIndicesCount; i++ {
			labelIndicesElement, err := r.readUint32LEB128InstructionArgument()
			if err != nil {
				return nil, err
			}
			labelIndices[i] = labelIndicesElement
		}

		defaultLabelIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionBrTable{
			LabelIndices:      labelIndices,
			DefaultLabelIndex: defaultLabelIndex,
		}, nil

	case opcodeCall:
		funcIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionCall{
			FuncIndex: funcIndex,
		}, nil

	case opcodeCallIndirect:
		typeIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		tableIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionCallIndirect{
			TypeIndex:  typeIndex,
			TableIndex: tableIndex,
		}, nil

	case opcodeDrop:
		return InstructionDrop{}, nil

	case opcodeEnd:
		return InstructionEnd{}, nil

	case opcodeGlobalGet:
		globalIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionGlobalGet{
			GlobalIndex: globalIndex,
		}, nil

	case opcodeGlobalSet:
		globalIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionGlobalSet{
			GlobalIndex: globalIndex,
		}, nil

	case opcodeI32Add:
		return InstructionI32Add{}, nil

	case opcodeI32And:
		return InstructionI32And{}, nil

	case opcodeI32Clz:
		return InstructionI32Clz{}, nil

	case opcodeI32Const:
		value, err := r.readInt32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionI32Const{
			Value: value,
		}, nil

	case opcodeI32Ctz:
		return InstructionI32Ctz{}, nil

	case opcodeI32DivS:
		return InstructionI32DivS{}, nil

	case opcodeI32DivU:
		return InstructionI32DivU{}, nil

	case opcodeI32Eq:
		return InstructionI32Eq{}, nil

	case opcodeI32Eqz:
		return InstructionI32Eqz{}, nil

	case opcodeI32GeS:
		return InstructionI32GeS{}, nil

	case opcodeI32GeU:
		return InstructionI32GeU{}, nil

	case opcodeI32GtS:
		return InstructionI32GtS{}, nil

	case opcodeI32GtU:
		return InstructionI32GtU{}, nil

	case opcodeI32LeS:
		return InstructionI32LeS{}, nil

	case opcodeI32LeU:
		return InstructionI32LeU{}, nil

	case opcodeI32LtS:
		return InstructionI32LtS{}, nil

	case opcodeI32LtU:
		return InstructionI32LtU{}, nil

	case opcodeI32Mul:
		return InstructionI32Mul{}, nil

	case opcodeI32Ne:
		return InstructionI32Ne{}, nil

	case opcodeI32Or:
		return InstructionI32Or{}, nil

	case opcodeI32Popcnt:
		return InstructionI32Popcnt{}, nil

	case opcodeI32RemS:
		return InstructionI32RemS{}, nil

	case opcodeI32RemU:
		return InstructionI32RemU{}, nil

	case opcodeI32Rotl:
		return InstructionI32Rotl{}, nil

	case opcodeI32Rotr:
		return InstructionI32Rotr{}, nil

	case opcodeI32Shl:
		return InstructionI32Shl{}, nil

	case opcodeI32ShrS:
		return InstructionI32ShrS{}, nil

	case opcodeI32ShrU:
		return InstructionI32ShrU{}, nil

	case opcodeI32Sub:
		return InstructionI32Sub{}, nil

	case opcodeI32WrapI64:
		return InstructionI32WrapI64{}, nil

	case opcodeI32Xor:
		return InstructionI32Xor{}, nil

	case opcodeI64Add:
		return InstructionI64Add{}, nil

	case opcodeI64And:
		return InstructionI64And{}, nil

	case opcodeI64Clz:
		return InstructionI64Clz{}, nil

	case opcodeI64Const:
		value, err := r.readInt64LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionI64Const{
			Value: value,
		}, nil

	case opcodeI64Ctz:
		return InstructionI64Ctz{}, nil

	case opcodeI64DivS:
		return InstructionI64DivS{}, nil

	case opcodeI64DivU:
		return InstructionI64DivU{}, nil

	case opcodeI64Eq:
		return InstructionI64Eq{}, nil

	case opcodeI64Eqz:
		return InstructionI64Eqz{}, nil

	case opcodeI64ExtendI32S:
		return InstructionI64ExtendI32S{}, nil

	case opcodeI64ExtendI32U:
		return InstructionI64ExtendI32U{}, nil

	case opcodeI64GeS:
		return InstructionI64GeS{}, nil

	case opcodeI64GeU:
		return InstructionI64GeU{}, nil

	case opcodeI64GtS:
		return InstructionI64GtS{}, nil

	case opcodeI64GtU:
		return InstructionI64GtU{}, nil

	case opcodeI64LeS:
		return InstructionI64LeS{}, nil

	case opcodeI64LeU:
		return InstructionI64LeU{}, nil

	case opcodeI64LtS:
		return InstructionI64LtS{}, nil

	case opcodeI64LtU:
		return InstructionI64LtU{}, nil

	case opcodeI64Mul:
		return InstructionI64Mul{}, nil

	case opcodeI64Ne:
		return InstructionI64Ne{}, nil

	case opcodeI64Or:
		return InstructionI64Or{}, nil

	case opcodeI64Popcnt:
		return InstructionI64Popcnt{}, nil

	case opcodeI64RemS:
		return InstructionI64RemS{}, nil

	case opcodeI64RemU:
		return InstructionI64RemU{}, nil

	case opcodeI64Rotl:
		return InstructionI64Rotl{}, nil

	case opcodeI64Rotr:
		return InstructionI64Rotr{}, nil

	case opcodeI64Shl:
		return InstructionI64Shl{}, nil

	case opcodeI64ShrS:
		return InstructionI64ShrS{}, nil

	case opcodeI64ShrU:
		return InstructionI64ShrU{}, nil

	case opcodeI64Sub:
		return InstructionI64Sub{}, nil

	case opcodeI64Xor:
		return InstructionI64Xor{}, nil

	case opcodeIf:
		block, err := r.readBlockInstructionArgument(true)
		if err != nil {
			return nil, err
		}

		return InstructionIf{
			Block: block,
		}, nil

	case opcodeLocalGet:
		localIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionLocalGet{
			LocalIndex: localIndex,
		}, nil

	case opcodeLocalSet:
		localIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionLocalSet{
			LocalIndex: localIndex,
		}, nil

	case opcodeLocalTee:
		localIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionLocalTee{
			LocalIndex: localIndex,
		}, nil

	case opcodeLoop:
		block, err := r.readBlockInstructionArgument(false)
		if err != nil {
			return nil, err
		}

		return InstructionLoop{
			Block: block,
		}, nil

	case opcodeNop:
		return InstructionNop{}, nil

	case opcodeRefFunc:
		funcIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionRefFunc{
			FuncIndex: funcIndex,
		}, nil

	case opcodeRefIsNull:
		return InstructionRefIsNull{}, nil

	case opcodeRefNull:
		typeIndex, err := r.readUint32LEB128InstructionArgument()
		if err != nil {
			return nil, err
		}

		return InstructionRefNull{
			TypeIndex: typeIndex,
		}, nil

	case opcodeReturn:
		return InstructionReturn{}, nil

	case opcodeSelect:
		return InstructionSelect{}, nil

	case opcodeUnreachable:
		return InstructionUnreachable{}, nil

	default:
		return nil, InvalidOpcodeError{
			Offset:    int(opcodeOffset),
			Opcode:    c,
			ReadError: err,
		}
	}

}
