rules:
  - super: Any
    predicate:
      always

  - super: AnyStruct
    predicate:
      and:
        - not:
            isResource: sub
        - not:
            equals:
              source: sub
              target: Any

  - super: AnyResource
    predicate:
      isResource: sub

  - super: AnyResourceAttachment
    predicate:
      and:
        - isAttachment: sub
        - isResource: sub

  - super: AnyStructAttachment
    predicate:
      and:
        - isAttachment: sub
        - not:
            isResource: sub

  - super: HashableStruct
    predicate:
      isHashableStruct: sub

  - super: Path
    predicate:
      subtype:
        sub: sub
        super:
          # Maybe use 'or' predicate here instead?
          # The difference is 'or' is a predicate containing zero or more inner predicates.
          # Whereas, 'oneOfTypes' contains zero or more types, not predicates.
          oneOfTypes: [StoragePath, CapabilityPath]

  - super: Storable
    predicate:
      isStorable: sub

  - super: CapabilityPath
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [PrivatePath, PublicPath]

  - super: Number
    predicate:
      or:
        - equals:
            source: sub
            target:
              oneOfTypes: [Number, SignedNumber]

        - subtype:
            sub: sub
            super:
              oneOfTypes: [Integer, FixedPoint]

  - super: SignedNumber
    predicate:
      or:
        - equals:
            source: sub
            target: SignedNumber

        - subtype:
            sub: sub
            super:
              oneOfTypes: [SignedInteger, SignedFixedPoint]

  - super: Integer
    predicate:
      or:
        - equals:
            source: sub
            target:
              oneOfTypes: [Integer, SignedInteger, FixedSizeUnsignedInteger, UInt]

        - subtype:
            sub: sub
            super:
              oneOfTypes: [SignedInteger, FixedSizeUnsignedInteger]

  - super: SignedInteger
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [SignedInteger, Int, Int8, Int16, Int32, Int64, Int128, Int256]

  - super: FixedSizeUnsignedInteger
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [UInt8, UInt16, UInt32, UInt64, UInt128, UInt256,
                  Word8, Word16, Word32, Word64, Word128, Word256]

  - super: FixedPoint
    predicate:
      or:
        - equals:
            source: sub
            target:
              oneOfTypes: [FixedPoint, SignedFixedPoint, UFix64, UFix128]

        - subtype:
            sub: sub
            super:
              oneOfTypes: [SignedFixedPoint]

  - super: SignedFixedPoint
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [SignedFixedPoint, Fix64, Fix128]

  - super: Optional
    sub: Optional
    predicate:
      subtype:
        super: super.Type
        sub: sub.Type

  - super: Dictionary
    sub: Dictionary
    predicate:
      and:
        - subtype:
            super: super.ValueType
            sub: sub.KeyType
        - subtype:
            super: super.ValueType
            sub: sub.KeyType

#  - super:
#      Reference:
#        auth: A
#        type: B
#    sub:
#      Reference:
#        auth: C
#        type: D
#    predicate:
#      and:
#        - permits: [B, A]
#        - equals:
#            source: D
#            target: B
#
#  - super:
#      Function:
#        purity: A
#        params: B
#        return: C
#    sub:
#      Function:
#        purity: X
#        params: Y
#        return: Z
#    predicate:
#      and:
#        - equals:
#            source: X
#            target:
#              oneOfTypes: [A, PurityView]
#        - typeParamsEqual
#        - paramsContravariant
#        - returnCovariant
#        - constructorEqual

#  - super:
#      Intersection:
#        set: A
#    sub:
#      Intersection:
#        set: B
#    predicate:
#      contains: [B, A]
