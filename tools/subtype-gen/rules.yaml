rules:
  - super: AnyType
    predicate:
      always

  - super: AnyStructType
    predicate:
      and:
        - not:
            isResource: sub
        - not:
            equals:
              source: sub
              target: AnyType

  - super: AnyResourceType
    predicate:
      isResource: sub

  - super: AnyResourceAttachmentType
    predicate:
      and:
        - isAttachment: sub
        - isResource: sub

  - super: AnyStructAttachmentType
    predicate:
      and:
        - isAttachment: sub
        - not:
            isResource: sub

  - super: HashableStructType
    predicate:
      isHashableStruct: sub

  - super: PathType
    predicate:
      subtype:
        sub: sub
        super:
          # Maybe use 'or' predicate here instead?
          # The difference is 'or' is a predicate containing zero or more inner predicates.
          # Whereas, 'oneOfTypes' contains zero or more types, not predicates.
          oneOfTypes: [StoragePathType, CapabilityPathType]

  - super: StorableType
    predicate:
      isStorable: sub

  - super: CapabilityPathType
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [PrivatePathType, PublicPathType]

  - super: NumberType
    predicate:
      or:
        - equals:
            source: sub
            target:
              oneOfTypes: [NumberType, SignedNumberType]

        - subtype:
            sub: sub
            super:
              oneOfTypes: [IntegerType, FixedPointType]

  - super: SignedNumberType
    predicate:
      or:
        - equals:
            source: sub
            target: SignedNumberType

        - subtype:
            sub: sub
            super:
              oneOfTypes: [SignedIntegerType, SignedFixedPointType]

  - super: IntegerType
    predicate:
      or:
        - equals:
            source: sub
            target:
              oneOfTypes: [IntegerType, SignedIntegerType, FixedSizeUnsignedIntegerType, UIntType]

        - subtype:
            sub: sub
            super:
              oneOfTypes: [SignedIntegerType, FixedSizeUnsignedIntegerType]

  - super: SignedIntegerType
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [SignedIntegerType, IntType, Int8Type, Int16Type, Int32Type, Int64Type, Int128Type, Int256Type]

  - super: FixedSizeUnsignedIntegerType
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [UInt8Type, UInt16Type, UInt32Type, UInt64Type, UInt128Type, UInt256Type,
                  Word8Type, Word16Type, Word32Type, Word64Type, Word128Type, Word256Type]

  - super: FixedPointType
    predicate:
      or:
        - equals:
            source: sub
            target:
              oneOfTypes: [FixedPointType, SignedFixedPointType, UFix64Type, UFix128Type]

        - subtype:
            sub: sub
            super:
              oneOfTypes: [SignedFixedPointType]

  - super: SignedFixedPointType
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [SignedFixedPointType, Fix64Type, Fix128Type]

  - super: OptionalType
    sub: OptionalType
    predicate:
      subtype:
        super: super.Type
        sub: sub.Type

  - super: Dictionary
    sub: Dictionary
    predicate:
      and:
        - subtype:
            super: super.ValueType
            sub: sub.ValueType
        - subtype:
            super: super.KeyType
            sub: sub.KeyType

#  - super:
#      Reference:
#        auth: A
#        type: B
#    sub:
#      Reference:
#        auth: C
#        type: D
#    predicate:
#      and:
#        - permits: [B, A]
#        - equals:
#            source: D
#            target: B
#
#  - super:
#      Function:
#        purity: A
#        params: B
#        return: C
#    sub:
#      Function:
#        purity: X
#        params: Y
#        return: Z
#    predicate:
#      and:
#        - equals:
#            source: X
#            target:
#              oneOfTypes: [A, PurityView]
#        - typeParamsEqual
#        - paramsContravariant
#        - returnCovariant
#        - constructorEqual

#  - super:
#      Intersection:
#        set: A
#    sub:
#      Intersection:
#        set: B
#    predicate:
#      contains: [B, A]
