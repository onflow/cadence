rules:
  - super: AnyType
    predicate:
      always

  - super: AnyStructType
    predicate:
      and:
        - not:
            isResource: sub
        - not:
            equals:
              source: sub
              target: AnyType

  - super: AnyResourceType
    predicate:
      isResource: sub

  - super: AnyResourceAttachmentType
    predicate:
      and:
        - isAttachment: sub
        - isResource: sub

  - super: AnyStructAttachmentType
    predicate:
      and:
        - isAttachment: sub
        - not:
            isResource: sub

  - super: HashableStructType
    predicate:
      isHashableStruct: sub

  - super: PathType
    predicate:
      subtype:
        sub: sub
        super:
          # Maybe use 'or' predicate here instead?
          # The difference is 'or' is a predicate containing zero or more inner predicates.
          # Whereas, 'oneOfTypes' contains zero or more types, not predicates.
          oneOfTypes: [StoragePathType, CapabilityPathType]

  - super: StorableType
    predicate:
      isStorable: sub

  - super: CapabilityPathType
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [PrivatePathType, PublicPathType]

  - super: NumberType
    predicate:
      or:
        - equals:
            source: sub
            target:
              oneOfTypes: [NumberType, SignedNumberType]

        - subtype:
            sub: sub
            super:
              oneOfTypes: [IntegerType, FixedPointType]

  - super: SignedNumberType
    predicate:
      or:
        - equals:
            source: sub
            target: SignedNumberType

        - subtype:
            sub: sub
            super:
              oneOfTypes: [SignedIntegerType, SignedFixedPointType]

  - super: IntegerType
    predicate:
      or:
        - equals:
            source: sub
            target:
              oneOfTypes: [IntegerType, SignedIntegerType, FixedSizeUnsignedIntegerType, UIntType]

        - subtype:
            sub: sub
            super:
              oneOfTypes: [SignedIntegerType, FixedSizeUnsignedIntegerType]

  - super: SignedIntegerType
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [SignedIntegerType, IntType, Int8Type, Int16Type, Int32Type, Int64Type, Int128Type, Int256Type]

  - super: FixedSizeUnsignedIntegerType
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [UInt8Type, UInt16Type, UInt32Type, UInt64Type, UInt128Type, UInt256Type,
                  Word8Type, Word16Type, Word32Type, Word64Type, Word128Type, Word256Type]

  - super: FixedPointType
    predicate:
      or:
        - equals:
            source: sub
            target:
              oneOfTypes: [FixedPointType, SignedFixedPointType, UFix64Type, UFix128Type]

        - subtype:
            sub: sub
            super:
              oneOfTypes: [SignedFixedPointType]

  - super: SignedFixedPointType
    predicate:
      equals:
        source: sub
        target:
          oneOfTypes: [SignedFixedPointType, Fix64Type, Fix128Type]

  - super: OptionalType
    predicate:
      or:
        - and:
            - mustType:
                source: sub
                type: OptionalType
            - subtype:
                super: super.Type
                sub: sub.Type
        - subtype:
            super: super.Type
            sub: sub

  - super: Dictionary
    predicate:
      and:
        - mustType:
            source: sub
            type: Dictionary
        - subtype:
            super: super.ValueType
            sub: sub.ValueType
        - subtype:
            super: super.KeyType
            sub: sub.KeyType

  - super: VariableSizedType
    predicate:
      and:
        - mustType:
            source: sub
            type: VariableSizedType
        - subtype:
            super: super.ElementType
            sub: sub.ElementType

  - super: ConstantSizedType
    predicate:
      and:
        - mustType:
            source: sub
            type: ConstantSizedType
        - equals:
            source: super.Size
            target: sub.Size
        - subtype:
            super: super.ElementType
            sub: sub.ElementType

  - super: ReferenceType
    predicate:
      and:
        - mustType:
            source: sub
            type: ReferenceType
        - permits:
            super: super.Authorization
            sub: sub.Authorization
        - subtype:
            super: super.Type
            sub: sub.Type

  - super: CompositeType
    predicate:
      or:
        - and:
          - mustType:
              source: sub
              type: IntersectionType
          - not:
              equals:
                source: sub.LegacyType
                target:
                  oneOfTypes: [nil, AnyResourceType, AnyStructType, AnyType]
          - mustType:
              source: sub.LegacyType
              type: CompositeType
          - equals:
              source: sub.LegacyType
              target: super
        - and:
            - mustType:
                source: sub
                type: CompositeType
            - never

  - super: InterfaceType
    predicate:
      or:
        - and:
          - mustType:
              source: sub
              type: CompositeType
          - equals:
              source: sub.Kind
              target: super.CompositeKind
          - setContains:
              source: sub.EffectiveInterfaceConformanceSet
              target: super
        - and:
          - mustType:
              source: sub
              type: IntersectionType
          - setContains:
              source: sub.EffectiveIntersectionSet
              target: super
        - and:
          - mustType:
              source: sub
              type: InterfaceType
          - setContains:
              source: sub.EffectiveInterfaceConformanceSet
              target: super

  - super: IntersectionType
    predicate:
      or:
        - and:
          - equals:
              source: super.LegacyType
              target:
                oneOfTypes: [nil, AnyType, AnyStructType, AnyResourceType]
          - and:
            - not:
                equals:
                  source: sub
                  target:
                    oneOfTypes: [AnyType, AnyStructType, AnyResourceType]
            - or:
              - and:
                - mustType:
                    source: sub
                    type: IntersectionType
                - or:
                    - and:
                      - equals:
                          source: sub.LegacyType
                          target: nil
                      - isIntersectionSubset:
                          super: super
                          sub: sub

                    - and:
                      - equals:
                          source: sub.LegacyType
                          target:
                            oneOfTypes: [AnyType, AnyStructType, AnyResourceType]

                      # Below two combination is repeated several times below.
                      # Maybe combine them to produce a single predicate.
                      - or:
                        - equals:
                            source: super.LegacyType
                            target: nil
                        - subtype:
                            super: super.LegacyType
                            sub: sub.LegacyType
                      - isIntersectionSubset:
                          super: super
                          sub: sub

                    - and:
                        - mustType:
                            source: sub.LegacyType
                            type: CompositeType
                        - or:
                            - equals:
                                source: super.LegacyType
                                target: nil
                            - subtype:
                                super: super.LegacyType
                                sub: sub.LegacyType
                        - isIntersectionSubset:
                            super: super
                            sub: sub.LegacyType
              - and:
                - mustType:
                    source: sub
                    type: ConformingType
                - or:
                    - equals:
                        source: super.LegacyType
                        target: nil
                    - subtype:
                        super: super.LegacyType
                        sub: sub
                - isIntersectionSubset:
                    super: super
                    sub: sub
        - and:
          - mustType:
              source: sub
              type: IntersectionType
          - not:
              equals:
                source: sub.LegacyType
                target:
                  oneOfTypes: [ nil, AnyType, AnyStructType, AnyResourceType ]
          - mustType:
              source: sub.LegacyType
              type: CompositeType
          - equals:
              source: sub.LegacyType
              target: super.LegacyType

        - and:
          - mustType:
              source: sub
              type: CompositeType
          - subtype:
              super: super.LegacyType
              sub: sub
        - not:
            equals:
              source: sub
              target:
                oneOfTypes: [AnyType, AnyStructType, AnyResourceType]

  - super: FunctionType
    predicate:
      and:
        - mustType:
            source: sub
            type: FunctionType
        - equals:
            source: sub.Purity
            target:
              oneOfTypes: [super.Purity, FunctionPurityView]
        - typeParamsEqual:
            source: sub
            target: super
        - paramsContravariant:
            source: sub
            target: super
        - returnCovariant:
            source: sub
            target: super
        - constructorEqual:
            source: sub
            target: super
