rules:
  - super: Any
    sub: T
    predicate:
      always

  - super: AnyStruct
    sub: T
    predicate:
      and:
        - not:
            isResource: T
        - not:
            equals:
              source: T
              target: Any

  - super: AnyResource
    sub: T
    predicate:
      isResource: T

  - super: AnyResourceAttachment
    sub: T
    predicate:
      and:
        - isAttachment: T
        - isResource: T

  - super: AnyStructAttachment
    sub: T
    predicate:
      and:
        - isAttachment: T
        - not:
            isResource: T

  - super: HashableStruct
    sub: T
    predicate:
      isHashableStruct: T

  - super: Path
    sub: T
    predicate:
      subtype:
        sub: T
        super:
          # Maybe use 'or' predicate here instead?
          # The difference is 'or' is a predicate containing zero or more inner predicates.
          # Whereas, 'oneOfTypes' contains zero or more types, not predicates.
          oneOfTypes: [StoragePath, CapabilityPath]

  - super: Storable
    sub: T
    predicate:
      isStorable: T

  - super: CapabilityPath
    sub: T
    predicate:
      equals:
        source: T
        target:
          oneOfTypes: [PrivatePath, PublicPath]

  - super: Number
    sub: T
    predicate:
      or:
        - equals:
            source: T
            target:
              oneOfTypes: [Number, SignedNumber]

        - subtype:
            sub: T
            super:
              oneOfTypes: [Integer, FixedPoint]

  - super: SignedNumber
    sub: T
    predicate:
      or:
        - equals:
            source: T
            target: SignedNumber

        - subtype:
            sub: T
            super:
              oneOfTypes: [SignedInteger, SignedFixedPoint]

  - super: Integer
    sub: T
    predicate:
      or:
        - equals:
            source: T
            target:
              oneOfTypes: [Integer, SignedInteger, FixedSizeUnsignedInteger, UInt]

        - subtype:
            sub: T
            super:
              oneOfTypes: [SignedInteger, FixedSizeUnsignedInteger]

  - super: SignedInteger
    sub: T
    predicate:
      equals:
        source: T
        target:
          oneOfTypes: [SignedInteger, Int, Int8, Int16, Int32, Int64, Int128, Int256]

  - super: FixedSizeUnsignedInteger
    sub: T
    predicate:
      equals:
        source: T
        target:
          oneOfTypes: [UInt8, UInt16, UInt32, UInt64, UInt128, UInt256,
                  Word8, Word16, Word32, Word64, Word128, Word256]

  - super: FixedPoint
    sub: T
    predicate:
      or: 
        - equals:
            source: T
            target:
              oneOfTypes: [FixedPoint, SignedFixedPoint, UFix64, UFix128]

        - subtype:
            sub: T
            super: 
              oneOfTypes: [SignedFixedPoint]

  - super: SignedFixedPoint
    sub: T
    predicate:
      equals:
        source: T
        target:
          oneOfTypes: [SignedFixedPoint, Fix64, Fix128]

#  - super:
#      Optional:
#        inner: U
#    sub: T
#    predicate:
#      equals:
#        source: T
#        target: U
#
#  - super:
#      Reference:
#        auth: A
#        type: B
#    sub:
#      Reference:
#        auth: C
#        type: D
#    predicate:
#      and:
#        - permits: [B, A]
#        - equals:
#            source: D
#            target: B
#
#  - super:
#      Function:
#        purity: A
#        params: B
#        return: C
#    sub:
#      Function:
#        purity: X
#        params: Y
#        return: Z
#    predicate:
#      and:
#        - equals:
#            source: X
#            target:
#              oneOfTypes: [A, PurityView]
#        - typeParamsEqual
#        - paramsContravariant
#        - returnCovariant
#        - constructorEqual
#
#  - super:
#      Dictionary:
#        key: A
#        value: B
#    sub:
#      Dictionary:
#        key: C
#        value: D
#    predicate:
#      and:
#        - equals:
#            source: C
#            target: A
#        - equals:
#            source: D
#            target: B
#
#  - super:
#      Intersection:
#        set: A
#    sub:
#      Intersection:
#        set: B
#    predicate:
#      contains: [B, A]
