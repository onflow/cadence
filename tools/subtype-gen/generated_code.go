package sema

// Code generated by tools/subtype-gen; DO NOT EDIT.
// Source: declarative rules

func checkSubTypeWithoutEquality(subType Type, superType Type) bool {

	if subType == NeverType {
		return true
	}

	switch superType {
	case AnyType:
		return true
	case AnyStructType:
		return !(subType.IsResourceType()) &&
				!(isAttachmentType(subType))
	case AnyResourceType:
		return subType.IsResourceType()
	case AnyResourceAttachmentType:
		return isAttachmentType(subType) &&
				subType.IsResourceType()
	case AnyStructAttachmentType:
		return isAttachmentType(subType) &&
				!(subType.IsResourceType())
	case HashableStructType:
		return IsHashableStructType(subType)
	case PathType:
		return IsSubType(subType, StoragePathType) ||
				IsSubType(subType, CapabilityPathType)
	case StorableType:
		storableResults := map[*Member]bool{}
				return subType.IsStorable(storableResults)
	case CapabilityPathType:
		switch subType {
				case PrivatePathType, PublicPathType:
					return true
				default:
					return false
				}
	case NumberType:
		return (subType == NumberType || subType == SignedNumberType) ||
				IsSubType(subType, IntegerType) ||
				IsSubType(subType, FixedPointType)
	case SignedNumberType:
		return subType == SignedNumberType ||
				IsSubType(subType, SignedIntegerType) ||
				IsSubType(subType, SignedFixedPointType)
	case IntegerType:
		return (subType == IntegerType || subType == SignedIntegerType || subType == FixedSizeUnsignedIntegerType || subType == UIntType) ||
				IsSubType(subType, SignedIntegerType) ||
				IsSubType(subType, FixedSizeUnsignedIntegerType)
	case SignedIntegerType:
		switch subType {
				case SignedIntegerType, IntType, Int8Type, Int16Type, Int32Type, Int64Type, Int128Type, Int256Type:
					return true
				default:
					return false
				}
	case FixedSizeUnsignedIntegerType:
		switch subType {
				case UInt8Type, UInt16Type, UInt32Type, UInt64Type, UInt128Type, UInt256Type, Word8Type, Word16Type, Word32Type, Word64Type, Word128Type, Word256Type:
					return true
				default:
					return false
				}
	case FixedPointType:
		return (subType == FixedPointType || subType == SignedFixedPointType || subType == UFix64Type || subType == UFix128Type) ||
				IsSubType(subType, SignedFixedPointType)
	case SignedFixedPointType:
		switch subType {
				case SignedFixedPointType, Fix64Type, Fix128Type:
					return true
				default:
					return false
				}
	case *OptionalType:
		return subType == UType
	case ReferenceType:
		return typedSuperType.Authorization.PermitsAccess(typedSubType.Authorization) &&
				subType == BType
	case FunctionType:
		return typedSubType.Purity == typedSuperType.Purity || typedSubType.Purity == FunctionPurityView &&
				len(typedSubType.TypeParameters) == len(typedSuperType.TypeParameters) &&
				// TODO: Implement params contravariant check &&
				// TODO: Implement covariant check &&
				typedSubType.IsConstructor == typedSuperType.IsConstructor
	case DictionaryType:
		return subType == AType &&
				subType == BType
	case IntersectionType:
		return typedSuperType.EffectiveIntersectionSet().IsSubsetOf(typedSubType.EffectiveIntersectionSet())
	}

	return false
}
