package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	yaml "gopkg.in/yaml.v3"
)

// Rule represents a single subtype rule
type Rule struct {
	Super any `yaml:"super"`
	Sub   any `yaml:"sub"`
	Rule  any `yaml:"rule"`
}

// RulesConfig represents the entire YAML configuration
type RulesConfig struct {
	Rules []Rule `yaml:"rules"`
}

// RuleCondition represents different types of conditions in rules
type RuleCondition struct {
	Always              bool              `yaml:"always,omitempty"`
	IsResource          any               `yaml:"isResource,omitempty"`
	IsAttachment        any               `yaml:"isAttachment,omitempty"`
	IsHashableStruct    any               `yaml:"isHashableStruct,omitempty"`
	IsStorable          any               `yaml:"isStorable,omitempty"`
	Equals              *EqualsCondition  `yaml:"equals,omitempty"`
	Subtype             *SubtypeCondition `yaml:"subtype,omitempty"`
	And                 []RuleCondition   `yaml:"and,omitempty"`
	Or                  []RuleCondition   `yaml:"or,omitempty"`
	Not                 *RuleCondition    `yaml:"not,omitempty"`
	Permits             []any             `yaml:"permits,omitempty"`
	Purity              *PurityCondition  `yaml:"purity,omitempty"`
	TypeParamsEqual     bool              `yaml:"typeParamsEqual,omitempty"`
	ParamsContravariant bool              `yaml:"paramsContravariant,omitempty"`
	ReturnCovariant     bool              `yaml:"returnCovariant,omitempty"`
	ConstructorEqual    bool              `yaml:"constructorEqual,omitempty"`
	Contains            []any             `yaml:"contains,omitempty"`
}

type EqualsCondition struct {
	Source any `yaml:"source"`
	Target any `yaml:"target"`
}

type KeyValues = map[string]any

type SubtypeCondition struct {
	Sub   any `yaml:"sub"`
	Super any `yaml:"super"`
}

type PurityCondition struct {
	EqualsOrView bool `yaml:"equals_or_view"`
}

func main() {
	var (
		yamlPath string
		outPath  string
		pkgName  string
		toStdout bool
	)
	flag.StringVar(&yamlPath, "rules", "rules.yaml", "path to YAML rules")
	flag.StringVar(&outPath, "out", "-", "output file path or '-' for stdout")
	flag.StringVar(&pkgName, "pkg", "sema", "target Go package name")
	flag.BoolVar(&toStdout, "stdout", false, "write to stdout")
	flag.Parse()

	// Read and parse YAML rules
	rules, err := readYAMLRules(yamlPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error reading YAML rules: %v\n", err)
		os.Exit(1)
	}

	// Generate code using the comprehensive generator
	code, err := generateComprehensiveCode(rules, pkgName)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error generating code: %v\n", err)
		os.Exit(1)
	}

	// Write output
	if err := writeOutput(outPath, code, toStdout); err != nil {
		fmt.Fprintf(os.Stderr, "error writing output: %v\n", err)
		os.Exit(1)
	}
}

// readYAMLRules reads and parses the YAML rules file
func readYAMLRules(path string) ([]Rule, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", path, err)
	}

	var config RulesConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse YAML: %w", err)
	}

	return config.Rules, nil
}

// writeOutput writes the generated code to the specified output
func writeOutput(dst string, content []byte, stdout bool) error {
	if stdout || dst == "-" {
		_, err := io.Copy(os.Stdout, bytes.NewReader(content))
		return err
	}

	if err := os.MkdirAll(filepath.Dir(dst), 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	return os.WriteFile(dst, content, 0o644)
}

// generateComprehensiveCode generates the complete checkSubTypeWithoutEquality function
func generateComprehensiveCode(rules []Rule, packageName string) ([]byte, error) {
	var buf bytes.Buffer

	// Write package declaration and header
	buf.WriteString("package " + packageName + "\n\n")
	buf.WriteString("// Code generated by tools/subtype-gen; DO NOT EDIT.\n")
	buf.WriteString("// Source: declarative rules\n\n")
	buf.WriteString("func checkSubTypeWithoutEquality(subType Type, superType Type) bool {\n\n")

	// Add early return for Never type
	buf.WriteString("\tif subType == NeverType {\n\t\treturn true\n\t}\n\n")

	// Generate switch statement for superType
	buf.WriteString("\tswitch superType {\n")

	// Process each rule
	for _, rule := range rules {
		code, err := generateRuleCode(rule)
		if err != nil {
			return nil, fmt.Errorf("error generating rule: %w", err)
		}
		buf.WriteString(code)
	}

	// Close switch and add final return
	buf.WriteString("\t}\n\n")
	buf.WriteString("\treturn false\n}\n")

	return buf.Bytes(), nil
}

// generateRuleCode generates Go code for a single rule
func generateRuleCode(rule Rule) (string, error) {
	var buf bytes.Buffer

	// Handle super type pattern
	superType, err := parseType(rule.Super)
	if err != nil {
		return "", fmt.Errorf("error parsing super type: %w", err)
	}

	// Handle subtype pattern
	subType, err := parseType(rule.Sub)
	if err != nil {
		return "", fmt.Errorf("error parsing sub type: %w", err)
	}

	// Generate case statement for super type
	caseCode, err := generateCaseCode(superType, subType, rule.Rule)
	if err != nil {
		return "", err
	}

	buf.WriteString(caseCode)
	return buf.String(), nil
}

// TypeInfo represents parsed type information
type TypeInfo struct {
	TypeName       string
	IsGeneric      bool
	GenericArgs    []TypeInfo
	IsOptional     bool
	IsReference    bool
	IsFunction     bool
	IsDictionary   bool
	IsIntersection bool
}

// parseType parses a type from YAML
func parseType(typeData any) (*TypeInfo, error) {
	switch v := typeData.(type) {
	case string:
		return &TypeInfo{TypeName: v}, nil
	case KeyValues:
		ti := &TypeInfo{}

		// Handle Optional type
		if optional, ok := v["Optional"].(KeyValues); ok {
			ti.IsOptional = true
			inner, err := parseType(optional["inner"])
			if err != nil {
				return nil, err
			}
			ti.GenericArgs = []TypeInfo{*inner}
			return ti, nil
		}

		// Handle Reference type
		if ref, ok := v["Reference"].(KeyValues); ok {
			ti.IsReference = true
			ti.TypeName = "Reference"
			// Parse auth and type parameters
			if auth, ok := ref["auth"]; ok {
				authType, err := parseType(auth)
				if err != nil {
					return nil, err
				}
				ti.GenericArgs = append(ti.GenericArgs, *authType)
			}
			if typeParam, ok := ref["type"]; ok {
				typeType, err := parseType(typeParam)
				if err != nil {
					return nil, err
				}
				ti.GenericArgs = append(ti.GenericArgs, *typeType)
			}
			return ti, nil
		}

		// Handle Function type
		if fn, ok := v["Function"].(KeyValues); ok {
			ti.IsFunction = true
			ti.TypeName = "Function"
			// Parse params and return
			if params, ok := fn["params"]; ok {
				paramsType, err := parseType(params)
				if err != nil {
					return nil, err
				}
				ti.GenericArgs = append(ti.GenericArgs, *paramsType)
			}
			if returnType, ok := fn["return"]; ok {
				returnTypeInfo, err := parseType(returnType)
				if err != nil {
					return nil, err
				}
				ti.GenericArgs = append(ti.GenericArgs, *returnTypeInfo)
			}
			return ti, nil
		}

		// Handle Dictionary type
		if dict, ok := v["Dictionary"].(KeyValues); ok {
			ti.IsDictionary = true
			ti.TypeName = "Dictionary"
			// Parse key and value
			if key, ok := dict["key"]; ok {
				keyType, err := parseType(key)
				if err != nil {
					return nil, err
				}
				ti.GenericArgs = append(ti.GenericArgs, *keyType)
			}
			if value, ok := dict["value"]; ok {
				valueType, err := parseType(value)
				if err != nil {
					return nil, err
				}
				ti.GenericArgs = append(ti.GenericArgs, *valueType)
			}
			return ti, nil
		}

		// Handle Intersection type
		if intersection, ok := v["Intersection"].(KeyValues); ok {
			ti.IsIntersection = true
			ti.TypeName = "Intersection"
			// Parse set
			if set, ok := intersection["set"]; ok {
				setType, err := parseType(set)
				if err != nil {
					return nil, err
				}
				ti.GenericArgs = []TypeInfo{*setType}
			}
			return ti, nil
		}

		return nil, fmt.Errorf("unsupported type pattern: %v", v)
	default:
		return nil, fmt.Errorf("unsupported type: %T", typeData)
	}
}

// generateCaseCode generates a case statement for a type
func generateCaseCode(superType, subType *TypeInfo, rule any) (string, error) {
	var buf bytes.Buffer

	// Generate case condition
	caseCondition, err := generateCaseCondition(superType)
	if err != nil {
		return "", err
	}

	buf.WriteString("\tcase " + caseCondition + ":\n")

	// Generate rule body
	ruleBody, err := generateRuleBody(superType, subType, rule)
	if err != nil {
		return "", err
	}

	// Indent the rule body
	indentedBody := indentCode(ruleBody, 2)
	buf.WriteString(indentedBody)
	buf.WriteString("\n")

	return buf.String(), nil
}

// generateCaseCondition generates the case condition for a type
func generateCaseCondition(typeInfo *TypeInfo) (string, error) {
	if typeInfo.TypeName != "" && !typeInfo.IsGeneric {
		return getTypeConstant(typeInfo.TypeName), nil
	}

	if typeInfo.IsOptional {
		return "*OptionalType", nil
	}

	if typeInfo.IsReference {
		return "*ReferenceType", nil
	}

	if typeInfo.IsFunction {
		return "*FunctionType", nil
	}

	if typeInfo.IsDictionary {
		return "*DictionaryType", nil
	}

	if typeInfo.IsIntersection {
		return "*IntersectionType", nil
	}

	return "", fmt.Errorf("unsupported case condition type")
}

// generateRuleBody generates the body of a rule
func generateRuleBody(superType, subType *TypeInfo, rule any) (string, error) {
	// Parse rule condition
	condition, err := parseRuleCondition(rule)
	if err != nil {
		return "", err
	}

	return generateConditionCode(superType, subType, condition), nil
}

// parseRuleCondition parses a rule condition from YAML
func parseRuleCondition(rule any) (*RuleCondition, error) {
	switch v := rule.(type) {
	case string:
		if v == "always" {
			return &RuleCondition{Always: true}, nil
		}
		return nil, fmt.Errorf("unsupported string rule: %s", v)
	case KeyValues:
		rc := &RuleCondition{}

		// Parse all possible conditions
		if always, ok := v["always"].(bool); ok {
			rc.Always = always
		}

		if isResource, ok := v["isResource"]; ok {
			rc.IsResource = isResource
		}

		if isAttachment, ok := v["isAttachment"]; ok {
			rc.IsAttachment = isAttachment
		}

		if isHashableStruct, ok := v["isHashableStruct"]; ok {
			rc.IsHashableStruct = isHashableStruct
		}

		if isStorable, ok := v["isStorable"]; ok {
			rc.IsStorable = isStorable
		}

		if equals, ok := v["equals"].(KeyValues); ok {
			rc.Equals = &EqualsCondition{
				Source: equals["source"],
				Target: equals["target"],
			}
		}

		if subtype, ok := v["subtype"].(KeyValues); ok {
			rc.Subtype = &SubtypeCondition{
				Sub:   subtype["sub"],
				Super: subtype["super"],
			}
		}

		if and, ok := v["and"].([]any); ok {
			for _, cond := range and {
				parsed, err := parseRuleCondition(cond)
				if err != nil {
					return nil, err
				}
				rc.And = append(rc.And, *parsed)
			}
		}

		if or, ok := v["or"].([]any); ok {
			for _, cond := range or {
				parsed, err := parseRuleCondition(cond)
				if err != nil {
					return nil, err
				}
				rc.Or = append(rc.Or, *parsed)
			}
		}

		if not, ok := v["not"]; ok {
			parsed, err := parseRuleCondition(not)
			if err != nil {
				return nil, err
			}
			rc.Not = parsed
		}

		if permits, ok := v["permits"].([]any); ok {
			rc.Permits = permits
		}

		if purity, ok := v["purity"].(KeyValues); ok {
			rc.Purity = &PurityCondition{
				EqualsOrView: purity["equals_or_view"].(bool),
			}
		}

		if typeParamsEqual, ok := v["typeParamsEqual"].(bool); ok {
			rc.TypeParamsEqual = typeParamsEqual
		}

		if paramsContravariant, ok := v["paramsContravariant"].(bool); ok {
			rc.ParamsContravariant = paramsContravariant
		}

		if returnCovariant, ok := v["returnCovariant"].(bool); ok {
			rc.ReturnCovariant = returnCovariant
		}

		if constructorEqual, ok := v["constructorEqual"].(bool); ok {
			rc.ConstructorEqual = constructorEqual
		}

		if contains, ok := v["contains"].([]any); ok {
			rc.Contains = contains
		}

		return rc, nil
	default:
		return nil, fmt.Errorf("unsupported rule type: %T", rule)
	}
}

// generateConditionCode generates Go code for a rule condition
func generateConditionCode(superType, subType *TypeInfo, condition *RuleCondition) string {
	if condition.Always {
		return "return true"
	}

	if condition.IsResource != nil {
		return "return subType.IsResourceType()"
	}

	if condition.IsAttachment != nil {
		return "return isAttachmentType(subType)"
	}

	if condition.IsHashableStruct != nil {
		return "return IsHashableStructType(subType)"
	}

	if condition.IsStorable != nil {
		return "storableResults := map[*Member]bool{}\n\t\treturn subType.IsStorable(storableResults)"
	}

	if condition.Not != nil {
		innerCode := generateConditionCode(superType, subType, condition.Not)
		return "return !(" + strings.Replace(innerCode, "return ", "", 1) + ")"
	}

	if condition.And != nil && len(condition.And) > 0 {
		var conditions []string
		for _, cond := range condition.And {
			code := generateConditionCode(superType, subType, &cond)
			// Remove "return " prefix and add proper indentation
			cleanCode := strings.Replace(code, "return ", "", 1)
			conditions = append(conditions, cleanCode)
		}
		return "return " + strings.Join(conditions, " &&\n\t\t")
	}

	if condition.Or != nil && len(condition.Or) > 0 {
		var conditions []string
		for _, cond := range condition.Or {
			code := generateConditionCode(superType, subType, &cond)
			// Remove "return " prefix and add proper indentation
			cleanCode := strings.Replace(code, "return ", "", 1)
			// Convert switch statements to OR conditions for OR contexts
			cleanCode = convertSwitchToOrCondition(cleanCode)
			conditions = append(conditions, cleanCode)
		}
		return "return " + strings.Join(conditions, " ||\n\t\t")
	}

	if condition.Equals != nil {
		code := generateEqualsCondition(condition.Equals)
		if !strings.HasPrefix(code, "return ") && !strings.HasPrefix(code, "switch ") {
			return "return " + code
		}
		return code
	}

	if condition.Subtype != nil {
		code := generateSubtypeCondition(condition.Subtype)
		if !strings.HasPrefix(code, "return ") {
			return "return " + code
		}
		return code
	}

	if condition.Permits != nil && len(condition.Permits) == 2 {
		return "return typedSuperType.Authorization.PermitsAccess(typedSubType.Authorization)"
	}

	if condition.Purity != nil {
		return "return typedSubType.Purity == typedSuperType.Purity || typedSubType.Purity == FunctionPurityView"
	}

	if condition.TypeParamsEqual {
		return "return len(typedSubType.TypeParameters) == len(typedSuperType.TypeParameters)"
	}

	if condition.ParamsContravariant {
		return "// TODO: Implement params contravariant check"
	}

	if condition.ReturnCovariant {
		return "// TODO: Implement return covariant check"
	}

	if condition.ConstructorEqual {
		return "return typedSubType.IsConstructor == typedSuperType.IsConstructor"
	}

	if condition.Contains != nil && len(condition.Contains) == 2 {
		return "return typedSuperType.EffectiveIntersectionSet().IsSubsetOf(typedSubType.EffectiveIntersectionSet())"
	}

	return "// TODO: Implement condition"
}

// convertSwitchToOrCondition converts a switch statement to OR conditions
func convertSwitchToOrCondition(code string) string {
	if !strings.HasPrefix(code, "switch ") {
		return code
	}

	// Extract case values from switch statement
	lines := strings.Split(code, "\n")
	var caseConditions []string

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "case ") && !strings.Contains(line, "return true") {
			// Extract the case values
			casePart := strings.TrimSpace(strings.TrimPrefix(line, "case "))
			casePart = strings.TrimSuffix(casePart, ":")
			caseValues := strings.Split(casePart, ", ")
			for _, value := range caseValues {
				value = strings.TrimSpace(value)
				caseConditions = append(caseConditions, "subType == "+value)
			}
		}
	}

	if len(caseConditions) > 0 {
		return "(" + strings.Join(caseConditions, " || ") + ")"
	}

	return code
}

// generateEqualsCondition generates code for equals conditions
func generateEqualsCondition(equals *EqualsCondition) string {
	switch target := equals.Target.(type) {
	case string:
		return "subType == " + getTypeConstant(target)
	case KeyValues:
		for key, value := range target {
			switch key {
			case "oneOf":
				// TODO: Extract this out and make it recursive.

				// Value is always an array for `oneOf` rule.
				oneOf := value.([]any)
				var cases []string
				for _, t := range oneOf {
					if str, ok := t.(string); ok {
						cases = append(cases, getTypeConstant(str))
					}
				}
				return "switch subType {\n\t\tcase " + strings.Join(cases, ", ") + ":\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}"
			default:
				panic(fmt.Errorf("unsupported rule `%s` for `target` of `equals` rule", key))
			}
		}
	default:
		panic(fmt.Errorf("unknown target type %t in `equals` rule", target))
	}

	return "// TODO: Implement equals condition"
}

// generateSubtypeCondition generates code for subtype conditions
func generateSubtypeCondition(subtype *SubtypeCondition) string {
	// Handle oneOf super type
	if superMap, ok := subtype.Super.(KeyValues); ok {
		if oneOf, ok := superMap["oneOf"].([]any); ok {
			var conditions []string
			for _, t := range oneOf {
				if str, ok := t.(string); ok {
					conditions = append(conditions, "IsSubType(subType, "+getTypeConstant(str)+")")
				}
			}
			return strings.Join(conditions, " ||\n\t\t")
		}
	}

	// Handle simple string super type
	if superStr, ok := subtype.Super.(string); ok {
		return "IsSubType(subType, " + getTypeConstant(superStr) + ")"
	}

	return "// TODO: Implement subtype condition"
}

// getTypeConstant converts a type name to its Go constant
func getTypeConstant(typeName string) string {
	switch typeName {
	case "Any":
		return "AnyType"
	case "AnyStruct":
		return "AnyStructType"
	case "AnyResource":
		return "AnyResourceType"
	case "AnyResourceAttachment":
		return "AnyResourceAttachmentType"
	case "AnyStructAttachment":
		return "AnyStructAttachmentType"
	case "HashableStruct":
		return "HashableStructType"
	case "Path":
		return "PathType"
	case "Storable":
		return "StorableType"
	case "CapabilityPath":
		return "CapabilityPathType"
	case "Number":
		return "NumberType"
	case "SignedNumber":
		return "SignedNumberType"
	case "Integer":
		return "IntegerType"
	case "SignedInteger":
		return "SignedIntegerType"
	case "FixedSizeUnsignedInteger":
		return "FixedSizeUnsignedIntegerType"
	case "FixedPoint":
		return "FixedPointType"
	case "SignedFixedPoint":
		return "SignedFixedPointType"
	case "UInt":
		return "UIntType"
	case "Int":
		return "IntType"
	case "Int8":
		return "Int8Type"
	case "Int16":
		return "Int16Type"
	case "Int32":
		return "Int32Type"
	case "Int64":
		return "Int64Type"
	case "Int128":
		return "Int128Type"
	case "Int256":
		return "Int256Type"
	case "UInt8":
		return "UInt8Type"
	case "UInt16":
		return "UInt16Type"
	case "UInt32":
		return "UInt32Type"
	case "UInt64":
		return "UInt64Type"
	case "UInt128":
		return "UInt128Type"
	case "UInt256":
		return "UInt256Type"
	case "Word8":
		return "Word8Type"
	case "Word16":
		return "Word16Type"
	case "Word32":
		return "Word32Type"
	case "Word64":
		return "Word64Type"
	case "Word128":
		return "Word128Type"
	case "Word256":
		return "Word256Type"
	case "UFix64":
		return "UFix64Type"
	case "UFix128":
		return "UFix128Type"
	case "Fix64":
		return "Fix64Type"
	case "Fix128":
		return "Fix128Type"
	case "StoragePath":
		return "StoragePathType"
	case "PrivatePath":
		return "PrivatePathType"
	case "PublicPath":
		return "PublicPathType"
	default:
		return typeName + "Type"
	}
}

// indentCode indents code by the specified number of tabs
func indentCode(code string, tabs int) string {
	lines := strings.Split(code, "\n")
	indent := strings.Repeat("\t", tabs)

	var result []string
	for _, line := range lines {
		if line == "" {
			result = append(result, "")
		} else {
			result = append(result, indent+line)
		}
	}

	return strings.Join(result, "\n")
}
