package main

import (
	"fmt"
	"strings"
)

type SubTypeCheckGenerator struct {
	typePkgName      string
	typePkgQualifier string
}

func NewSubTypeCheckGenerator(typePackageName string) *SubTypeCheckGenerator {
	parts := strings.Split(typePackageName, "/")
	return &SubTypeCheckGenerator{
		typePkgName:      typePackageName,
		typePkgQualifier: parts[len(parts)-1],
	}
}

// generateCheckSubTypeWithoutEqualityFunction generates the complete checkSubTypeWithoutEquality function.
func (gen *SubTypeCheckGenerator) generateCheckSubTypeWithoutEqualityFunction(rules []Rule) (string, error) {
	var b strings.Builder

	// Write package declaration and header
	b.WriteString("package main\n\n")
	b.WriteString("// Code generated by tools/subtype-gen; DO NOT EDIT.\n")

	b.WriteString("import \"")
	b.WriteString(gen.typePkgName)
	b.WriteString("\"\n\n")

	b.WriteString(fmt.Sprintf(
		"func checkSubTypeWithoutEquality(subType %[1]s.Type, superType %[1]s.Type) bool {\n\n",
		gen.typePkgQualifier,
	))

	// Add early return for Never type
	b.WriteString(
		fmt.Sprintf(
			"\tif subType == %s.NeverType {\n\t\treturn true\n\t}\n\n",
			gen.typePkgQualifier,
		),
	)

	// Generate switch statement for superType
	b.WriteString("\tswitch superType {\n")

	// Process each rule
	for _, rule := range rules {
		err := gen.generateRuleCode(&b, rule)
		if err != nil {
			return "", fmt.Errorf("error generating rule: %w", err)
		}
	}

	// Close switch and add final return
	b.WriteString("\t}\n\n")
	b.WriteString("\treturn false\n}\n")

	return b.String(), nil
}

// generateRuleCode generates Go code for a single rule.
// Each rule becomes a 'case' of a Go switch-case.
func (gen *SubTypeCheckGenerator) generateRuleCode(b *strings.Builder, rule Rule) error {
	// Handle super type pattern
	superType, err := parseType(rule.Super)
	if err != nil {
		return fmt.Errorf("error parsing super type: %w", err)
	}

	// Generate case condition.
	caseCondition, err := gen.generateCaseCondition(superType)
	if err != nil {
		return err
	}

	b.WriteString("\tcase " + caseCondition + ":\n")

	// Generate rule body
	ruleBody, err := gen.generateRuleBody(rule.Condition)
	if err != nil {
		return err
	}

	// Indent the rule body
	indentedBody := gen.indentCode(ruleBody, 2)
	b.WriteString(indentedBody)
	b.WriteString("\n")

	return nil
}

// generateCaseCondition generates the case condition for a type
func (gen *SubTypeCheckGenerator) generateCaseCondition(superType *TypeInfo) (string, error) {
	if superType.TypeName != "" && !superType.IsGeneric {
		return gen.qualifiedType(superType.TypeName), nil
	}

	if superType.IsOptional {
		return "*OptionalType", nil
	}

	if superType.IsReference {
		return "*ReferenceType", nil
	}

	if superType.IsFunction {
		return "*FunctionType", nil
	}

	if superType.IsDictionary {
		return "*DictionaryType", nil
	}

	if superType.IsIntersection {
		return "*IntersectionType", nil
	}

	return "", fmt.Errorf("unsupported case condition type")
}

// generateRuleBody generates the body of a rule
func (gen *SubTypeCheckGenerator) generateRuleBody(rule any) (string, error) {
	// Parse rule condition
	condition, err := parseRuleCondition(rule)
	if err != nil {
		return "", err
	}

	return gen.generateConditionCode(condition), nil
}

// generateConditionCode generates Go code for a rule condition
func (gen *SubTypeCheckGenerator) generateConditionCode(condition RuleCondition) string {
	switch c := condition.(type) {
	case AlwaysCondition:
		return "return true"

	case IsResourceCondition:
		return "return subType.IsResourceType()"

	case IsAttachmentCondition:
		return "return isAttachmentType(subType)"

	case IsHashableStructCondition:
		return "return IsHashableStructType(subType)"

	case IsStorableCondition:
		return "storableResults := map[*Member]bool{}\n\t\treturn subType.IsStorable(storableResults)"

	case NotCondition:
		innerCode := gen.generateConditionCode(c.Condition)
		return "return !(" + strings.Replace(innerCode, "return ", "", 1) + ")"

	case AndCondition:
		var conditions []string
		for _, cond := range c.Conditions {
			code := gen.generateConditionCode(cond)
			// Remove "return " prefix and add proper indentation
			cleanCode := strings.Replace(code, "return ", "", 1)
			conditions = append(conditions, cleanCode)
		}
		return "return " + strings.Join(conditions, " &&\n\t\t")

	case OrCondition:
		var conditions []string
		for _, cond := range c.Conditions {
			code := gen.generateConditionCode(cond)
			// Remove "return " prefix and add proper indentation
			cleanCode := strings.Replace(code, "return ", "", 1)
			// Convert switch statements to OR conditions for OR contexts
			cleanCode = gen.convertSwitchToOrCondition(cleanCode)
			conditions = append(conditions, cleanCode)
		}
		return "return " + strings.Join(conditions, " ||\n\t\t")

	case EqualsCondition:
		code := gen.generateEqualsCondition(&c)
		if !strings.HasPrefix(code, "return ") && !strings.HasPrefix(code, "switch ") {
			return "return " + code
		}
		return code

	case SubtypeCondition:
		code := gen.generateSubtypeCondition(&c)
		if !strings.HasPrefix(code, "return ") {
			return "return " + code
		}
		return code

	case PermitsCondition:
		if len(c.Types) == 2 {
			return "return typedSuperType.Authorization.PermitsAccess(typedSubType.Authorization)"
		}
		return "// TODO: Implement permits condition"

	case PurityCondition:
		return "return typedSubType.Purity == typedSuperType.Purity || typedSubType.Purity == FunctionPurityView"

	case TypeParamsEqualCondition:
		return "return len(typedSubType.TypeParameters) == len(typedSuperType.TypeParameters)"

	case ParamsContravariantCondition:
		return "// TODO: Implement params contravariant check"

	case ReturnCovariantCondition:
		return "// TODO: Implement return covariant check"

	case ConstructorEqualCondition:
		return "return typedSubType.IsConstructor == typedSuperType.IsConstructor"

	case ContainsCondition:
		if len(c.Types) == 2 {
			return "return typedSuperType.EffectiveIntersectionSet().IsSubsetOf(typedSubType.EffectiveIntersectionSet())"
		}
		return "// TODO: Implement contains condition"

	default:
		return "// TODO: Implement condition: " + condition.GetType()
	}
}

// convertSwitchToOrCondition converts a switch statement to OR conditions
func (gen *SubTypeCheckGenerator) convertSwitchToOrCondition(code string) string {
	if !strings.HasPrefix(code, "switch ") {
		return code
	}

	// Extract case values from switch statement
	lines := strings.Split(code, "\n")
	var caseConditions []string

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "case ") && !strings.Contains(line, "return true") {
			// Extract the case values
			casePart := strings.TrimSpace(strings.TrimPrefix(line, "case "))
			casePart = strings.TrimSuffix(casePart, ":")
			caseValues := strings.Split(casePart, ", ")
			for _, value := range caseValues {
				value = strings.TrimSpace(value)
				caseConditions = append(caseConditions, "subType == "+value)
			}
		}
	}

	if len(caseConditions) > 0 {
		return "(" + strings.Join(caseConditions, " || ") + ")"
	}

	return code
}

// generateEqualsCondition generates code for `equals` condition.
func (gen *SubTypeCheckGenerator) generateEqualsCondition(equals *EqualsCondition) string {
	switch target := equals.Target.(type) {
	case string:
		return "subType == " + gen.qualifiedType(target)
	case KeyValues:
		for key, value := range target {
			switch key {
			case "oneOf":
				// TODO: Extract this out and make it recursive.

				// Value is always an array for `oneOf` rule.
				oneOf := value.([]any)
				var cases []string
				for _, t := range oneOf {
					if str, ok := t.(string); ok {
						cases = append(cases, gen.qualifiedType(str))
					}
				}
				return "switch subType {\n\t\tcase " +
					strings.Join(cases, ", ") +
					":\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}"
			default:
				panic(fmt.Errorf("unsupported rule `%s` for `target` of `equals` rule", key))
			}
		}
	default:
		panic(fmt.Errorf("unknown target type %t in `equals` rule", target))
	}

	return "// TODO: Implement equals condition"
}

// generateSubtypeCondition generates code for `subtype` condition.
func (gen *SubTypeCheckGenerator) generateSubtypeCondition(subtype *SubtypeCondition) string {
	switch superType := subtype.Super.(type) {
	case string:
		return "IsSubType(subType, " + gen.qualifiedType(superType) + ")"
	case KeyValues:
		for key, value := range superType {
			switch key {
			case "oneOf":
				// Value is always an array for `oneOf` rule.
				oneOf := value.([]any)
				var conditions []string
				for _, t := range oneOf {
					if str, ok := t.(string); ok {
						conditions = append(conditions, "IsSubType(subType, "+gen.qualifiedType(str)+")")
					}
				}
				return strings.Join(conditions, " ||\n\t\t")
			default:
				panic(fmt.Errorf("unsupported rule `%s` for `target` of `equals` rule", key))
			}
		}
	default:
		panic(fmt.Errorf("unknown super %t in `subtype` rule", superType))
	}

	return "// TODO: Implement subtype condition"
}

func (gen *SubTypeCheckGenerator) qualifiedType(typeName string) string {
	return gen.typePkgQualifier + "." + gen.getTypeConstant(typeName)
}

// getTypeConstant converts a type name to its Go constant
func (gen *SubTypeCheckGenerator) getTypeConstant(placeholderTypeName string) string {
	switch placeholderTypeName {
	case "Any":
		return "AnyType"
	case "AnyStruct":
		return "AnyStructType"
	case "AnyResource":
		return "AnyResourceType"
	case "AnyResourceAttachment":
		return "AnyResourceAttachmentType"
	case "AnyStructAttachment":
		return "AnyStructAttachmentType"
	case "HashableStruct":
		return "HashableStructType"
	case "Path":
		return "PathType"
	case "Storable":
		return "StorableType"
	case "CapabilityPath":
		return "CapabilityPathType"
	case "Number":
		return "NumberType"
	case "SignedNumber":
		return "SignedNumberType"
	case "Integer":
		return "IntegerType"
	case "SignedInteger":
		return "SignedIntegerType"
	case "FixedSizeUnsignedInteger":
		return "FixedSizeUnsignedIntegerType"
	case "FixedPoint":
		return "FixedPointType"
	case "SignedFixedPoint":
		return "SignedFixedPointType"
	case "UInt":
		return "UIntType"
	case "Int":
		return "IntType"
	case "Int8":
		return "Int8Type"
	case "Int16":
		return "Int16Type"
	case "Int32":
		return "Int32Type"
	case "Int64":
		return "Int64Type"
	case "Int128":
		return "Int128Type"
	case "Int256":
		return "Int256Type"
	case "UInt8":
		return "UInt8Type"
	case "UInt16":
		return "UInt16Type"
	case "UInt32":
		return "UInt32Type"
	case "UInt64":
		return "UInt64Type"
	case "UInt128":
		return "UInt128Type"
	case "UInt256":
		return "UInt256Type"
	case "Word8":
		return "Word8Type"
	case "Word16":
		return "Word16Type"
	case "Word32":
		return "Word32Type"
	case "Word64":
		return "Word64Type"
	case "Word128":
		return "Word128Type"
	case "Word256":
		return "Word256Type"
	case "UFix64":
		return "UFix64Type"
	case "UFix128":
		return "UFix128Type"
	case "Fix64":
		return "Fix64Type"
	case "Fix128":
		return "Fix128Type"
	case "StoragePath":
		return "StoragePathType"
	case "PrivatePath":
		return "PrivatePathType"
	case "PublicPath":
		return "PublicPathType"
	default:
		return placeholderTypeName + "Type"
	}
}

// indentCode indents code by the specified number of tabs
func (gen *SubTypeCheckGenerator) indentCode(code string, tabs int) string {
	lines := strings.Split(code, "\n")
	indent := strings.Repeat("\t", tabs)

	var result []string
	for _, line := range lines {
		if line == "" {
			result = append(result, "")
		} else {
			result = append(result, indent+line)
		}
	}

	return strings.Join(result, "\n")
}
