package main

import (
	"bytes"
	"fmt"
	"strings"
)

// generateComprehensiveCode generates the complete checkSubTypeWithoutEquality function
func generateComprehensiveCode(rules []Rule, packageName string) ([]byte, error) {
	var buf bytes.Buffer

	// Write package declaration and header
	buf.WriteString("package " + packageName + "\n\n")
	buf.WriteString("// Code generated by tools/subtype-gen; DO NOT EDIT.\n")
	buf.WriteString("// Source: declarative rules\n\n")
	buf.WriteString("func checkSubTypeWithoutEquality(subType Type, superType Type) bool {\n\n")

	// Add early return for Never type
	buf.WriteString("\tif subType == NeverType {\n\t\treturn true\n\t}\n\n")

	// Generate switch statement for superType
	buf.WriteString("\tswitch superType {\n")

	// Process each rule
	for _, rule := range rules {
		code, err := generateRuleCode(rule)
		if err != nil {
			return nil, fmt.Errorf("error generating rule: %w", err)
		}
		buf.WriteString(code)
	}

	// Close switch and add final return
	buf.WriteString("\t}\n\n")
	buf.WriteString("\treturn false\n}\n")

	return buf.Bytes(), nil
}

// generateRuleCode generates Go code for a single rule
func generateRuleCode(rule Rule) (string, error) {
	var buf bytes.Buffer

	// Handle super type pattern
	superType, err := parseType(rule.Super)
	if err != nil {
		return "", fmt.Errorf("error parsing super type: %w", err)
	}

	caseCode, err := generateCaseCode(superType, rule.Condition)
	if err != nil {
		return "", err
	}

	buf.WriteString(caseCode)
	return buf.String(), nil
}

// generateCaseCode generates a case statement for a type
func generateCaseCode(superType *TypeInfo, rule any) (string, error) {
	var buf bytes.Buffer

	// Generate case condition
	caseCondition, err := generateCaseCondition(superType)
	if err != nil {
		return "", err
	}

	buf.WriteString("\tcase " + caseCondition + ":\n")

	// Generate rule body
	ruleBody, err := generateRuleBody(rule)
	if err != nil {
		return "", err
	}

	// Indent the rule body
	indentedBody := indentCode(ruleBody, 2)
	buf.WriteString(indentedBody)
	buf.WriteString("\n")

	return buf.String(), nil
}

// generateCaseCondition generates the case condition for a type
func generateCaseCondition(typeInfo *TypeInfo) (string, error) {
	if typeInfo.TypeName != "" && !typeInfo.IsGeneric {
		return getTypeConstant(typeInfo.TypeName), nil
	}

	if typeInfo.IsOptional {
		return "*OptionalType", nil
	}

	if typeInfo.IsReference {
		return "*ReferenceType", nil
	}

	if typeInfo.IsFunction {
		return "*FunctionType", nil
	}

	if typeInfo.IsDictionary {
		return "*DictionaryType", nil
	}

	if typeInfo.IsIntersection {
		return "*IntersectionType", nil
	}

	return "", fmt.Errorf("unsupported case condition type")
}

// generateRuleBody generates the body of a rule
func generateRuleBody(rule any) (string, error) {
	// Parse rule condition
	condition, err := parseRuleCondition(rule)
	if err != nil {
		return "", err
	}

	return generateConditionCode(condition), nil
}

// generateConditionCode generates Go code for a rule condition
func generateConditionCode(condition RuleCondition) string {
	switch c := condition.(type) {
	case AlwaysCondition:
		return "return true"

	case IsResourceCondition:
		return "return subType.IsResourceType()"

	case IsAttachmentCondition:
		return "return isAttachmentType(subType)"

	case IsHashableStructCondition:
		return "return IsHashableStructType(subType)"

	case IsStorableCondition:
		return "storableResults := map[*Member]bool{}\n\t\treturn subType.IsStorable(storableResults)"

	case NotCondition:
		innerCode := generateConditionCode(c.Condition)
		return "return !(" + strings.Replace(innerCode, "return ", "", 1) + ")"

	case AndCondition:
		var conditions []string
		for _, cond := range c.Conditions {
			code := generateConditionCode(cond)
			// Remove "return " prefix and add proper indentation
			cleanCode := strings.Replace(code, "return ", "", 1)
			conditions = append(conditions, cleanCode)
		}
		return "return " + strings.Join(conditions, " &&\n\t\t")

	case OrCondition:
		var conditions []string
		for _, cond := range c.Conditions {
			code := generateConditionCode(cond)
			// Remove "return " prefix and add proper indentation
			cleanCode := strings.Replace(code, "return ", "", 1)
			// Convert switch statements to OR conditions for OR contexts
			cleanCode = convertSwitchToOrCondition(cleanCode)
			conditions = append(conditions, cleanCode)
		}
		return "return " + strings.Join(conditions, " ||\n\t\t")

	case EqualsCondition:
		code := generateEqualsCondition(&c)
		if !strings.HasPrefix(code, "return ") && !strings.HasPrefix(code, "switch ") {
			return "return " + code
		}
		return code

	case SubtypeCondition:
		code := generateSubtypeCondition(&c)
		if !strings.HasPrefix(code, "return ") {
			return "return " + code
		}
		return code

	case PermitsCondition:
		if len(c.Types) == 2 {
			return "return typedSuperType.Authorization.PermitsAccess(typedSubType.Authorization)"
		}
		return "// TODO: Implement permits condition"

	case PurityCondition:
		return "return typedSubType.Purity == typedSuperType.Purity || typedSubType.Purity == FunctionPurityView"

	case TypeParamsEqualCondition:
		return "return len(typedSubType.TypeParameters) == len(typedSuperType.TypeParameters)"

	case ParamsContravariantCondition:
		return "// TODO: Implement params contravariant check"

	case ReturnCovariantCondition:
		return "// TODO: Implement return covariant check"

	case ConstructorEqualCondition:
		return "return typedSubType.IsConstructor == typedSuperType.IsConstructor"

	case ContainsCondition:
		if len(c.Types) == 2 {
			return "return typedSuperType.EffectiveIntersectionSet().IsSubsetOf(typedSubType.EffectiveIntersectionSet())"
		}
		return "// TODO: Implement contains condition"

	default:
		return "// TODO: Implement condition: " + condition.GetType()
	}
}

// convertSwitchToOrCondition converts a switch statement to OR conditions
func convertSwitchToOrCondition(code string) string {
	if !strings.HasPrefix(code, "switch ") {
		return code
	}

	// Extract case values from switch statement
	lines := strings.Split(code, "\n")
	var caseConditions []string

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "case ") && !strings.Contains(line, "return true") {
			// Extract the case values
			casePart := strings.TrimSpace(strings.TrimPrefix(line, "case "))
			casePart = strings.TrimSuffix(casePart, ":")
			caseValues := strings.Split(casePart, ", ")
			for _, value := range caseValues {
				value = strings.TrimSpace(value)
				caseConditions = append(caseConditions, "subType == "+value)
			}
		}
	}

	if len(caseConditions) > 0 {
		return "(" + strings.Join(caseConditions, " || ") + ")"
	}

	return code
}

// generateEqualsCondition generates code for equals conditions
func generateEqualsCondition(equals *EqualsCondition) string {
	switch target := equals.Target.(type) {
	case string:
		return "subType == " + getTypeConstant(target)
	case KeyValues:
		for key, value := range target {
			switch key {
			case "oneOf":
				// TODO: Extract this out and make it recursive.

				// Value is always an array for `oneOf` rule.
				oneOf := value.([]any)
				var cases []string
				for _, t := range oneOf {
					if str, ok := t.(string); ok {
						cases = append(cases, getTypeConstant(str))
					}
				}
				return "switch subType {\n\t\tcase " +
					strings.Join(cases, ", ") +
					":\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}"
			default:
				panic(fmt.Errorf("unsupported rule `%s` for `target` of `equals` rule", key))
			}
		}
	default:
		panic(fmt.Errorf("unknown target type %t in `equals` rule", target))
	}

	return "// TODO: Implement equals condition"
}

// generateSubtypeCondition generates code for subtype conditions
func generateSubtypeCondition(subtype *SubtypeCondition) string {
	// Handle oneOf super type
	if superMap, ok := subtype.Super.(KeyValues); ok {
		if oneOf, ok := superMap["oneOf"].([]any); ok {
			var conditions []string
			for _, t := range oneOf {
				if str, ok := t.(string); ok {
					conditions = append(conditions, "IsSubType(subType, "+getTypeConstant(str)+")")
				}
			}
			return strings.Join(conditions, " ||\n\t\t")
		}
	}

	// Handle simple string super type
	if superStr, ok := subtype.Super.(string); ok {
		return "IsSubType(subType, " + getTypeConstant(superStr) + ")"
	}

	return "// TODO: Implement subtype condition"
}

// getTypeConstant converts a type name to its Go constant
func getTypeConstant(typeName string) string {
	switch typeName {
	case "Any":
		return "AnyType"
	case "AnyStruct":
		return "AnyStructType"
	case "AnyResource":
		return "AnyResourceType"
	case "AnyResourceAttachment":
		return "AnyResourceAttachmentType"
	case "AnyStructAttachment":
		return "AnyStructAttachmentType"
	case "HashableStruct":
		return "HashableStructType"
	case "Path":
		return "PathType"
	case "Storable":
		return "StorableType"
	case "CapabilityPath":
		return "CapabilityPathType"
	case "Number":
		return "NumberType"
	case "SignedNumber":
		return "SignedNumberType"
	case "Integer":
		return "IntegerType"
	case "SignedInteger":
		return "SignedIntegerType"
	case "FixedSizeUnsignedInteger":
		return "FixedSizeUnsignedIntegerType"
	case "FixedPoint":
		return "FixedPointType"
	case "SignedFixedPoint":
		return "SignedFixedPointType"
	case "UInt":
		return "UIntType"
	case "Int":
		return "IntType"
	case "Int8":
		return "Int8Type"
	case "Int16":
		return "Int16Type"
	case "Int32":
		return "Int32Type"
	case "Int64":
		return "Int64Type"
	case "Int128":
		return "Int128Type"
	case "Int256":
		return "Int256Type"
	case "UInt8":
		return "UInt8Type"
	case "UInt16":
		return "UInt16Type"
	case "UInt32":
		return "UInt32Type"
	case "UInt64":
		return "UInt64Type"
	case "UInt128":
		return "UInt128Type"
	case "UInt256":
		return "UInt256Type"
	case "Word8":
		return "Word8Type"
	case "Word16":
		return "Word16Type"
	case "Word32":
		return "Word32Type"
	case "Word64":
		return "Word64Type"
	case "Word128":
		return "Word128Type"
	case "Word256":
		return "Word256Type"
	case "UFix64":
		return "UFix64Type"
	case "UFix128":
		return "UFix128Type"
	case "Fix64":
		return "Fix64Type"
	case "Fix128":
		return "Fix128Type"
	case "StoragePath":
		return "StoragePathType"
	case "PrivatePath":
		return "PrivatePathType"
	case "PublicPath":
		return "PublicPathType"
	default:
		return typeName + "Type"
	}
}

// indentCode indents code by the specified number of tabs
func indentCode(code string, tabs int) string {
	lines := strings.Split(code, "\n")
	indent := strings.Repeat("\t", tabs)

	var result []string
	for _, line := range lines {
		if line == "" {
			result = append(result, "")
		} else {
			result = append(result, indent+line)
		}
	}

	return strings.Join(result, "\n")
}
