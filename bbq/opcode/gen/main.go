package main

import (
	"bytes"
	"fmt"
	"go/token"
	"io"
	"os"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/decorator/resolver/guess"
	"github.com/goccy/go-yaml"
)

const (
	opcodePackagePath      = "github.com/onflow/cadence/bbq/opcode"
	commonPackagePath      = "github.com/onflow/cadence/common"
	errorsPackagePath      = "github.com/onflow/cadence/errors"
	constantPackagePath    = "github.com/onflow/cadence/bbq/constant"
	interpreterPackagePath = "github.com/onflow/cadence/interpreter"
)

const headerFormat = `// Code generated by gen/main.go from %s. DO NOT EDIT.

`

const typeCommentFormat = `// %s
//
// %s
`

type operandType string

const (
	operandTypeBool          = "bool"
	operandTypeLocalIndex    = "localIndex"
	operandTypeGlobalIndex   = "globalIndex"
	operandTypeTypeIndex     = "typeIndex"
	operandTypeConstantIndex = "constantIndex"
	operandTypeFunctionIndex = "functionIndex"
	operandTypeUpvalueIndex  = "upvalueIndex"
	operandTypeOffset        = "offset"
	operandTypeTypeIndices   = "typeIndices"
	operandTypeSize          = "size"
	operandTypeCastKind      = "castKind"
	operandTypePathDomain    = "pathDomain"
	operandTypeCompositeKind = "compositeKind"
	operandTypeUpvalues      = "upvalues"
)

type instruction struct {
	Name           string
	Description    string
	Operands       []operand
	ControlEffects []controlEffect `yaml:"controlEffects"`
}

type controlEffect struct {
	// only one of the following should be set
	Jump   *string   `yaml:"jump,omitempty"`
	Call   *struct{} `yaml:"call,omitempty"`
	Return *string   `yaml:"return,omitempty"`
}

type operand struct {
	Name        string
	Description string
	Type        operandType
}

func (ins instruction) hasControlEffects() bool {
	return len(ins.ControlEffects) > 0
}

func main() {
	if len(os.Args) != 3 {
		panic("usage: gen instructions.yml instructions.go")
	}

	yamlPath := os.Args[1]
	goPath := os.Args[2]

	yamlContents, err := os.ReadFile(yamlPath)
	if err != nil {
		panic(err)
	}

	var instructions []instruction

	err = yaml.Unmarshal(yamlContents, &instructions)
	if err != nil {
		panic(err)
	}

	var buffer bytes.Buffer
	_, err = fmt.Fprintf(&buffer, headerFormat, yamlPath)
	if err != nil {
		panic(err)
	}

	var decls []dst.Decl

	// Generate regular instruction types
	for _, instruction := range instructions {
		decls = append(
			decls,
			instructionDecls(instruction)...,
		)
	}

	// Generate pretty instruction types
	for _, instruction := range instructions {
		decls = append(
			decls,
			prettyInstructionDecls(instruction)...,
		)
	}

	decls = append(decls, decodeInstructionFuncDecl(instructions))

	writeGoFile(&buffer, decls, opcodePackagePath)

	err = os.WriteFile(goPath, buffer.Bytes(), 0644)
	if err != nil {
		panic(err)
	}

	// Compute the path for opcode_flow.go relative to instructions.go
	opcodeDir := ""
	if idx := strings.LastIndex(goPath, "/"); idx >= 0 {
		opcodeDir = goPath[:idx+1]
	}
	generatedOpcodePath := opcodeDir + "opcode_flow.go"

	// write opcode.isControlFlow to separate hardcoded file
	buffer.Reset()
	_, err = fmt.Fprintf(&buffer, headerFormat, yamlPath)
	if err != nil {
		panic(err)
	}

	writeGoFile(&buffer, []dst.Decl{generateIsControlFlowMethod(instructions)}, opcodePackagePath)

	err = os.WriteFile(generatedOpcodePath, buffer.Bytes(), 0644)
	if err != nil {
		panic(err)
	}
}

func generateIsControlFlowMethod(instructions []instruction) *dst.FuncDecl {
	var caseExprs []dst.Expr

	for _, ins := range instructions {
		if ins.hasControlEffects() {
			caseExprs = append(caseExprs, dst.NewIdent(firstUpper(ins.Name)))
		}
	}

	return &dst.FuncDecl{
		Recv: &dst.FieldList{
			List: []*dst.Field{
				{
					Names: []*dst.Ident{dst.NewIdent("i")},
					Type:  dst.NewIdent("Opcode"),
				},
			},
		},
		Name: dst.NewIdent("IsControlFlow"),
		Type: &dst.FuncType{
			Results: &dst.FieldList{
				List: []*dst.Field{{Type: dst.NewIdent("bool")}},
			},
		},
		Body: &dst.BlockStmt{
			List: []dst.Stmt{
				&dst.SwitchStmt{
					Tag: dst.NewIdent("i"),
					Body: &dst.BlockStmt{
						List: []dst.Stmt{
							&dst.CaseClause{
								List: caseExprs,
								Body: []dst.Stmt{
									&dst.ReturnStmt{
										Results: []dst.Expr{dst.NewIdent("true")},
									},
								},
							},
							&dst.CaseClause{
								Body: []dst.Stmt{
									&dst.ReturnStmt{
										Results: []dst.Expr{dst.NewIdent("false")},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func decodeInstructionFuncDecl(instructions []instruction) *dst.FuncDecl {

	var caseStmts []dst.Stmt

	for _, ins := range instructions {

		var resultExpr dst.Expr
		if len(ins.Operands) == 0 {
			resultExpr = &dst.CompositeLit{
				Type: instructionIdent(ins),
			}
		} else {
			resultExpr = &dst.CallExpr{
				Fun: &dst.Ident{
					Name: "Decode" + firstUpper(ins.Name),
				},
				Args: []dst.Expr{
					dst.NewIdent("ip"),
					dst.NewIdent("code"),
				},
			}
		}

		caseStmts = append(
			caseStmts,
			&dst.CaseClause{
				List: []dst.Expr{
					dst.NewIdent(firstUpper(ins.Name)),
				},
				Body: []dst.Stmt{
					&dst.ReturnStmt{
						Results: []dst.Expr{
							resultExpr,
						},
					},
				},
			},
		)
	}

	switchStmt := &dst.SwitchStmt{
		Tag: &dst.CallExpr{
			Fun: &dst.Ident{
				Name: "Opcode",
				Path: opcodePackagePath,
			},
			Args: []dst.Expr{
				&dst.CallExpr{

					Fun: &dst.Ident{
						Name: "decodeByte",
						Path: opcodePackagePath,
					},
					Args: []dst.Expr{
						dst.NewIdent("ip"),
						dst.NewIdent("code"),
					},
				},
			},
		},
		Body: &dst.BlockStmt{
			List: caseStmts,
		},
		Decs: dst.SwitchStmtDecorations{
			NodeDecs: dst.NodeDecs{
				Before: dst.NewLine,
				After:  dst.NewLine,
			},
		},
	}

	stmts := []dst.Stmt{
		switchStmt,
		&dst.ExprStmt{
			X: &dst.CallExpr{
				Fun: dst.NewIdent("panic"),
				Args: []dst.Expr{
					&dst.CallExpr{
						Fun: &dst.Ident{
							Name: "NewUnreachableError",
							Path: errorsPackagePath,
						},
					},
				},
			},
			Decs: dst.ExprStmtDecorations{
				NodeDecs: dst.NodeDecs{
					Before: dst.EmptyLine,
					After:  dst.NewLine,
				},
			},
		},
	}

	return &dst.FuncDecl{
		Name: dst.NewIdent("DecodeInstruction"),
		Type: &dst.FuncType{
			Params: &dst.FieldList{
				List: []*dst.Field{
					{
						Names: []*dst.Ident{
							dst.NewIdent("ip"),
						},
						Type: &dst.StarExpr{
							X: dst.NewIdent("uint16"),
						},
					},
					{
						Names: []*dst.Ident{
							dst.NewIdent("code"),
						},
						Type: &dst.ArrayType{
							Elt: dst.NewIdent("byte"),
						},
					},
				},
			},
			Results: &dst.FieldList{
				List: []*dst.Field{
					{
						Type: &dst.Ident{
							Name: "Instruction",
							Path: opcodePackagePath,
						},
					},
				},
			},
		},
		Body: &dst.BlockStmt{
			List: stmts,
		},
	}
}

func instructionDecls(instruction instruction) []dst.Decl {
	decls := []dst.Decl{
		instructionTypeDecl(instruction),
		instructionConformanceDecl(instruction),
		instructionOpcodeFuncDecl(instruction),
		instructionStringFuncDecl(instruction),
		instructionOperandsStringFuncDecl(instruction),
		instructionResolvedOperandsStringFuncDecl(instruction),
		instructionEncodeFuncDecl(instruction),
	}
	if len(instruction.Operands) > 0 {
		decls = append(decls, instructionDecodeFuncDecl(instruction))
	}
	// Add Pretty() method for all instructions
	decls = append(decls, instructionPrettyMethodDecl(instruction))
	return decls
}

func instructionIdent(ins instruction) *dst.Ident {
	return dst.NewIdent("Instruction" + firstUpper(ins.Name))
}

func operandIdent(o operand) *dst.Ident {
	return dst.NewIdent(firstUpper(o.Name))
}

func instructionTypeDecl(ins instruction) dst.Decl {
	comment := fmt.Sprintf(
		typeCommentFormat,
		instructionIdent(ins).String(),
		strings.ReplaceAll(ins.Description, "\n", "\n// "),
	)

	return &dst.GenDecl{
		Tok: token.TYPE,
		Specs: []dst.Spec{
			&dst.TypeSpec{
				Name: instructionIdent(ins),
				Type: &dst.StructType{
					Fields: instructionOperandsFields(ins),
				},
			},
		},
		Decs: dst.GenDeclDecorations{
			NodeDecs: dst.NodeDecs{
				Start: []string{comment},
			},
		},
	}
}

func instructionOperandsFields(ins instruction) *dst.FieldList {
	fields := make([]*dst.Field, len(ins.Operands))
	for i, operand := range ins.Operands {

		var typeExpr dst.Expr

		switch operand.Type {
		case operandTypeBool:
			typeExpr = dst.NewIdent("bool")

		case operandTypeLocalIndex,
			operandTypeGlobalIndex,
			operandTypeTypeIndex,
			operandTypeConstantIndex,
			operandTypeFunctionIndex,
			operandTypeUpvalueIndex,
			operandTypeOffset,
			operandTypeSize:

			typeExpr = dst.NewIdent("uint16")

		case operandTypeTypeIndices:
			typeExpr = &dst.ArrayType{
				Elt: dst.NewIdent("uint16"),
			}

		case operandTypeCastKind:
			typeExpr = &dst.Ident{
				Name: "CastKind",
				Path: opcodePackagePath,
			}

		case operandTypePathDomain:
			typeExpr = &dst.Ident{
				Name: "PathDomain",
				Path: commonPackagePath,
			}

		case operandTypeCompositeKind:
			typeExpr = &dst.Ident{
				Name: "CompositeKind",
				Path: commonPackagePath,
			}

		case operandTypeUpvalues:
			typeExpr = &dst.ArrayType{
				Elt: &dst.Ident{
					Name: "Upvalue",
					Path: opcodePackagePath,
				},
			}

		default:
			panic(fmt.Sprintf("unsupported operand type: %s", operand.Type))
		}

		fields[i] = &dst.Field{
			Names: []*dst.Ident{
				operandIdent(operand),
			},
			Type: typeExpr,
		}
	}
	return &dst.FieldList{
		List: fields,
	}
}

func instructionConformanceDecl(ins instruction) *dst.GenDecl {
	return &dst.GenDecl{
		Tok: token.VAR,
		Specs: []dst.Spec{
			&dst.ValueSpec{
				Names: []*dst.Ident{
					dst.NewIdent("_"),
				},
				Type: &dst.Ident{
					Name: "Instruction",
					Path: opcodePackagePath,
				},
				Values: []dst.Expr{
					&dst.CompositeLit{
						Type: instructionIdent(ins),
					},
				},
			},
		},
	}
}

func instructionOpcodeFuncDecl(ins instruction) *dst.FuncDecl {
	stmt := &dst.ReturnStmt{
		Results: []dst.Expr{
			dst.NewIdent(firstUpper(ins.Name)),
		},
		Decs: dst.ReturnStmtDecorations{
			NodeDecs: dst.NodeDecs{
				Before: dst.NewLine,
				After:  dst.NewLine,
			},
		},
	}
	return &dst.FuncDecl{
		Recv: &dst.FieldList{
			List: []*dst.Field{
				{
					Type: instructionIdent(ins),
				},
			},
		},
		Name: dst.NewIdent("Opcode"),
		Type: &dst.FuncType{
			Params: &dst.FieldList{},
			Results: &dst.FieldList{
				List: []*dst.Field{
					{
						Type: &dst.Ident{
							Name: "Opcode",
							Path: opcodePackagePath,
						},
					},
				},
			},
		},
		Body: &dst.BlockStmt{
			List: []dst.Stmt{
				stmt,
			},
		},
	}
}

func instructionStringFuncDecl(ins instruction) *dst.FuncDecl {

	var stmts []dst.Stmt

	opcodeStringExpr := &dst.CallExpr{
		Fun: &dst.SelectorExpr{
			X: &dst.CallExpr{
				Fun: &dst.SelectorExpr{
					X:   dst.NewIdent("i"),
					Sel: dst.NewIdent("Opcode"),
				},
			},
			Sel: dst.NewIdent("String"),
		},
	}

	if len(ins.Operands) == 0 {
		stmt := &dst.ReturnStmt{
			Results: []dst.Expr{
				opcodeStringExpr,
			},
			Decs: dst.ReturnStmtDecorations{
				NodeDecs: dst.NodeDecs{
					Before: dst.NewLine,
					After:  dst.NewLine,
				},
			},
		}
		stmts = append(stmts, stmt)
	} else {

		stmts = append(
			stmts,
			&dst.DeclStmt{
				Decl: &dst.GenDecl{
					Tok: token.VAR,
					Specs: []dst.Spec{
						&dst.ValueSpec{
							Names: []*dst.Ident{
								dst.NewIdent("sb"),
							},
							Type: &dst.Ident{
								Path: "strings",
								Name: "Builder",
							},
						},
					},
				},
				Decs: dst.DeclStmtDecorations{
					NodeDecs: dst.NodeDecs{
						Before: dst.NewLine,
						After:  dst.NewLine,
					},
				},
			},
		)

		stmts = append(
			stmts,
			&dst.ExprStmt{
				X: &dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X:   dst.NewIdent("sb"),
						Sel: dst.NewIdent("WriteString"),
					},
					Args: []dst.Expr{
						opcodeStringExpr,
					},
				},
			},
			&dst.ExprStmt{
				X: &dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X:   dst.NewIdent("i"),
						Sel: dst.NewIdent("OperandsString"),
					},
					Args: []dst.Expr{
						&dst.UnaryExpr{
							Op: token.AND,
							X:  dst.NewIdent("sb"),
						},
						dst.NewIdent("false"),
					},
				},
			},
			&dst.ReturnStmt{
				Results: []dst.Expr{
					&dst.CallExpr{
						Fun: &dst.SelectorExpr{
							X:   dst.NewIdent("sb"),
							Sel: dst.NewIdent("String"),
						},
					},
				},
				Decs: dst.ReturnStmtDecorations{
					NodeDecs: dst.NodeDecs{
						Before: dst.NewLine,
						After:  dst.NewLine,
					},
				},
			},
		)
	}

	return &dst.FuncDecl{
		Recv: &dst.FieldList{
			List: []*dst.Field{
				{
					Names: []*dst.Ident{
						dst.NewIdent("i"),
					},
					Type: instructionIdent(ins),
				},
			},
		},
		Name: dst.NewIdent("String"),
		Type: &dst.FuncType{
			Params: &dst.FieldList{},
			Results: &dst.FieldList{
				List: []*dst.Field{
					{
						Type: dst.NewIdent("string"),
					},
				},
			},
		},
		Body: &dst.BlockStmt{
			List: stmts,
		},
	}
}

func instructionOperandsStringFuncDecl(ins instruction) *dst.FuncDecl {

	var stmts []dst.Stmt

	for _, operand := range ins.Operands {
		var funcName string
		switch operand.Type {
		case operandTypeTypeIndices:
			funcName = "printfUInt16ArrayArgument"
		case operandTypeUpvalues:
			funcName = "printfUpvalueArrayArgument"
		default:
			funcName = "printfArgument"
		}

		stmts = append(
			stmts,
			&dst.ExprStmt{
				X: &dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X:   dst.NewIdent("sb"),
						Sel: dst.NewIdent("WriteByte"),
					},
					Args: []dst.Expr{
						&dst.BasicLit{
							Kind:  token.CHAR,
							Value: "' '",
						},
					},
				},
			},
			&dst.ExprStmt{
				X: &dst.CallExpr{
					Fun: &dst.Ident{
						Name: funcName,
					},
					Args: []dst.Expr{
						dst.NewIdent("sb"),
						&dst.BasicLit{
							Kind:  token.STRING,
							Value: fmt.Sprintf(`"%s"`, operand.Name),
						},
						&dst.SelectorExpr{
							X:   dst.NewIdent("i"),
							Sel: operandIdent(operand),
						},
						dst.NewIdent("colorize"),
					},
				},
			},
		)
	}

	return &dst.FuncDecl{
		Recv: &dst.FieldList{
			List: []*dst.Field{
				{
					Names: []*dst.Ident{
						dst.NewIdent("i"),
					},
					Type: instructionIdent(ins),
				},
			},
		},
		Name: dst.NewIdent("OperandsString"),
		Type: &dst.FuncType{
			Params: &dst.FieldList{
				List: []*dst.Field{
					{
						Names: []*dst.Ident{
							dst.NewIdent("sb"),
						},
						Type: &dst.StarExpr{
							X: &dst.Ident{
								Path: "strings",
								Name: "Builder",
							},
						},
					},
					{
						Names: []*dst.Ident{
							dst.NewIdent("colorize"),
						},
						Type: dst.NewIdent("bool"),
					},
				},
			},
		},
		Body: &dst.BlockStmt{
			List: stmts,
		},
	}
}

func instructionResolvedOperandsStringFuncDecl(ins instruction) *dst.FuncDecl {

	var stmts []dst.Stmt

	for _, operand := range ins.Operands {

		var (
			funcName  string
			arg       dst.Expr
			extraArgs []dst.Expr
		)

		switch operand.Type {
		case operandTypeTypeIndices:
			funcName = "printfTypeArrayArgument"
			extraArgs = []dst.Expr{
				&dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X:   dst.NewIdent("program"),
						Sel: dst.NewIdent("GetTypes"),
					},
				},
			}

		case operandTypeUpvalues:
			funcName = "printfUpvalueArrayArgument"

		case operandTypeConstantIndex:
			funcName = "printfConstantArgument"
			arg = &dst.IndexExpr{
				X: &dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X:   dst.NewIdent("program"),
						Sel: dst.NewIdent("GetConstants"),
					},
				},
				Index: &dst.SelectorExpr{
					X:   dst.NewIdent("i"),
					Sel: operandIdent(operand),
				},
			}

		case operandTypeTypeIndex:
			funcName = "printfTypeArgument"
			arg = &dst.IndexExpr{
				X: &dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X:   dst.NewIdent("program"),
						Sel: dst.NewIdent("GetTypes"),
					},
				},
				Index: &dst.SelectorExpr{
					X:   dst.NewIdent("i"),
					Sel: operandIdent(operand),
				},
			}

		case operandTypeFunctionIndex:
			funcName = "printfFunctionNameArgument"
			arg = &dst.CallExpr{
				Fun: &dst.SelectorExpr{
					X:   dst.NewIdent("program"),
					Sel: dst.NewIdent("GetFunctionName"),
				},
				Args: []dst.Expr{
					&dst.SelectorExpr{
						X:   dst.NewIdent("i"),
						Sel: operandIdent(operand),
					},
				},
			}

		default:
			funcName = "printfArgument"
		}

		if arg == nil {
			arg = &dst.SelectorExpr{
				X:   dst.NewIdent("i"),
				Sel: operandIdent(operand),
			}
		}

		stmts = append(
			stmts,
			&dst.ExprStmt{
				X: &dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X:   dst.NewIdent("sb"),
						Sel: dst.NewIdent("WriteByte"),
					},
					Args: []dst.Expr{
						&dst.BasicLit{
							Kind:  token.CHAR,
							Value: "' '",
						},
					},
				},
			},
			&dst.ExprStmt{
				X: &dst.CallExpr{
					Fun: &dst.Ident{
						Name: funcName,
					},
					Args: append(
						[]dst.Expr{
							dst.NewIdent("sb"),
							&dst.BasicLit{
								Kind:  token.STRING,
								Value: fmt.Sprintf(`"%s"`, operand.Name),
							},
							arg,
							dst.NewIdent("colorize"),
						},
						extraArgs...,
					),
				},
			},
		)
	}

	parameterFields := []*dst.Field{
		{
			Names: []*dst.Ident{
				dst.NewIdent("sb"),
			},
			Type: &dst.StarExpr{
				X: &dst.Ident{
					Path: "strings",
					Name: "Builder",
				},
			},
		},
		{
			Names: []*dst.Ident{
				dst.NewIdent("program"),
			},
			Type: &dst.Ident{
				Name: "ProgramForInstructions",
				Path: opcodePackagePath,
			},
		},
		{
			Names: []*dst.Ident{
				dst.NewIdent("colorize"),
			},
			Type: dst.NewIdent("bool"),
		},
	}

	for _, parameterField := range parameterFields {
		parameterField.Decorations().Before = dst.NewLine
		parameterField.Decorations().After = dst.NewLine
	}

	return &dst.FuncDecl{
		Recv: &dst.FieldList{
			List: []*dst.Field{
				{
					Names: []*dst.Ident{
						dst.NewIdent("i"),
					},
					Type: instructionIdent(ins),
				},
			},
		},
		Name: dst.NewIdent("ResolvedOperandsString"),
		Type: &dst.FuncType{
			Params: &dst.FieldList{
				List: parameterFields,
			},
		},
		Body: &dst.BlockStmt{
			List: stmts,
		},
	}
}

func instructionEncodeFuncDecl(ins instruction) *dst.FuncDecl {
	stmts := []dst.Stmt{
		&dst.ExprStmt{
			X: &dst.CallExpr{
				Fun: &dst.Ident{
					Name: "emitOpcode",
					Path: opcodePackagePath,
				},
				Args: []dst.Expr{
					dst.NewIdent("code"),
					&dst.CallExpr{
						Fun: &dst.SelectorExpr{
							X:   dst.NewIdent("i"),
							Sel: dst.NewIdent("Opcode"),
						},
					},
				},
			},
			Decs: dst.ExprStmtDecorations{
				NodeDecs: dst.NodeDecs{
					Before: dst.NewLine,
					After:  dst.NewLine,
				},
			},
		},
	}

	for _, operand := range ins.Operands {

		var funcName string

		switch operand.Type {
		case operandTypeBool:
			funcName = "emitBool"

		case operandTypeLocalIndex,
			operandTypeGlobalIndex,
			operandTypeTypeIndex,
			operandTypeConstantIndex,
			operandTypeFunctionIndex,
			operandTypeUpvalueIndex,
			operandTypeOffset,
			operandTypeSize:
			funcName = "emitUint16"

		case operandTypeTypeIndices:
			funcName = "emitUint16Array"

		case operandTypeCastKind:
			funcName = "emitCastKind"

		case operandTypePathDomain:
			funcName = "emitPathDomain"

		case operandTypeCompositeKind:
			funcName = "emitCompositeKind"

		case operandTypeUpvalues:
			funcName = "emitUpvalueArray"

		default:
			panic(fmt.Sprintf("unsupported operand type: %s", operand.Type))
		}

		stmts = append(stmts,
			&dst.ExprStmt{
				X: &dst.CallExpr{
					Fun: &dst.Ident{
						Name: funcName,
						Path: opcodePackagePath,
					},
					Args: []dst.Expr{
						dst.NewIdent("code"),
						&dst.SelectorExpr{
							X:   dst.NewIdent("i"),
							Sel: operandIdent(operand),
						},
					},
				},
				Decs: dst.ExprStmtDecorations{
					NodeDecs: dst.NodeDecs{
						Before: dst.NewLine,
						After:  dst.NewLine,
					},
				},
			},
		)
	}

	return &dst.FuncDecl{
		Recv: &dst.FieldList{
			List: []*dst.Field{
				{
					Names: []*dst.Ident{
						dst.NewIdent("i"),
					},
					Type: instructionIdent(ins),
				},
			},
		},
		Name: dst.NewIdent("Encode"),
		Type: &dst.FuncType{
			Params: &dst.FieldList{
				List: []*dst.Field{
					{
						Names: []*dst.Ident{
							dst.NewIdent("code"),
						},
						Type: &dst.StarExpr{
							X: &dst.ArrayType{
								Elt: dst.NewIdent("byte"),
							},
						},
					},
				},
			},
			Results: &dst.FieldList{},
		},
		Body: &dst.BlockStmt{
			List: stmts,
		},
	}
}

func instructionDecodeFuncDecl(ins instruction) *dst.FuncDecl {
	var stmts []dst.Stmt

	for _, operand := range ins.Operands {

		var funcName string

		switch operand.Type {
		case operandTypeBool:
			funcName = "decodeBool"

		case operandTypeLocalIndex,
			operandTypeGlobalIndex,
			operandTypeTypeIndex,
			operandTypeConstantIndex,
			operandTypeFunctionIndex,
			operandTypeUpvalueIndex,
			operandTypeOffset,
			operandTypeSize:
			funcName = "decodeUint16"

		case operandTypeTypeIndices:
			funcName = "decodeUint16Array"

		case operandTypeCastKind:
			funcName = "decodeCastKind"

		case operandTypePathDomain:
			funcName = "decodePathDomain"

		case operandTypeCompositeKind:
			funcName = "decodeCompositeKind"

		case operandTypeUpvalues:
			funcName = "decodeUpvalueArray"

		default:
			panic(fmt.Sprintf("unsupported operand type: %s", operand.Type))
		}

		stmts = append(stmts,
			&dst.AssignStmt{
				Lhs: []dst.Expr{
					&dst.SelectorExpr{
						X:   dst.NewIdent("i"),
						Sel: operandIdent(operand),
					},
				},
				Tok: token.ASSIGN,
				Rhs: []dst.Expr{
					&dst.CallExpr{
						Fun: &dst.Ident{
							Name: funcName,
							Path: opcodePackagePath,
						},
						Args: []dst.Expr{
							dst.NewIdent("ip"),
							dst.NewIdent("code"),
						},
					},
				},
				Decs: dst.AssignStmtDecorations{
					NodeDecs: dst.NodeDecs{
						Before: dst.NewLine,
						After:  dst.NewLine,
					},
				},
			},
		)
	}

	stmts = append(
		stmts,
		&dst.ReturnStmt{
			Results: []dst.Expr{
				dst.NewIdent("i"),
			},
			Decs: dst.ReturnStmtDecorations{
				NodeDecs: dst.NodeDecs{
					Before: dst.NewLine,
					After:  dst.NewLine,
				},
			},
		},
	)

	return &dst.FuncDecl{
		Name: dst.NewIdent("Decode" + firstUpper(ins.Name)),
		Type: &dst.FuncType{
			Params: &dst.FieldList{
				List: []*dst.Field{
					{
						Names: []*dst.Ident{
							dst.NewIdent("ip"),
						},
						Type: &dst.StarExpr{
							X: dst.NewIdent("uint16"),
						},
					},
					{
						Names: []*dst.Ident{
							dst.NewIdent("code"),
						},
						Type: &dst.ArrayType{
							Elt: dst.NewIdent("byte"),
						},
					},
				},
			},
			Results: &dst.FieldList{
				List: []*dst.Field{
					{
						Names: []*dst.Ident{
							dst.NewIdent("i"),
						},
						Type: instructionIdent(ins),
					},
				},
			},
		},
		Body: &dst.BlockStmt{
			List: stmts,
		},
	}
}

// prettyOperandType returns the resolved type for a given operand type
func prettyOperandType(operand operand) dst.Expr {
	switch operand.Type {
	case operandTypeConstantIndex:
		return &dst.Ident{
			Name: "DecodedConstant",
			Path: constantPackagePath,
		}
	case operandTypeTypeIndex:
		return &dst.Ident{
			Name: "StaticType",
			Path: interpreterPackagePath,
		}
	case operandTypeTypeIndices:
		return &dst.ArrayType{
			Elt: &dst.Ident{
				Name: "StaticType",
				Path: interpreterPackagePath,
			},
		}
	case operandTypeBool:
		return dst.NewIdent("bool")
	case operandTypeLocalIndex,
		operandTypeGlobalIndex,
		operandTypeUpvalueIndex,
		operandTypeFunctionIndex,
		operandTypeOffset,
		operandTypeSize:
		return dst.NewIdent("uint16")
	case operandTypeCastKind:
		return &dst.Ident{
			Name: "CastKind",
			Path: opcodePackagePath,
		}
	case operandTypePathDomain:
		return &dst.Ident{
			Name: "PathDomain",
			Path: commonPackagePath,
		}
	case operandTypeCompositeKind:
		return &dst.Ident{
			Name: "CompositeKind",
			Path: commonPackagePath,
		}
	case operandTypeUpvalues:
		return &dst.ArrayType{
			Elt: &dst.Ident{
				Name: "Upvalue",
				Path: opcodePackagePath,
			},
		}
	default:
		panic(fmt.Sprintf("unsupported operand type: %s", operand.Type))
	}
}

func prettyInstructionIdent(ins instruction) *dst.Ident {
	return dst.NewIdent("PrettyInstruction" + firstUpper(ins.Name))
}

// prettyInstructionDecls generates all declarations for a pretty instruction type
func prettyInstructionDecls(ins instruction) []dst.Decl {
	return []dst.Decl{
		prettyInstructionTypeDecl(ins),
		prettyInstructionConformanceDecl(ins),
		prettyInstructionOpcodeFuncDecl(ins),
		prettyInstructionStringFuncDecl(ins),
	}
}

// prettyInstructionTypeDecl generates the struct type declaration for a pretty instruction
func prettyInstructionTypeDecl(ins instruction) dst.Decl {
	comment := fmt.Sprintf(
		typeCommentFormat,
		prettyInstructionIdent(ins).String(),
		"Pretty form of "+instructionIdent(ins).String()+" with resolved operands.\n// "+
			strings.ReplaceAll(ins.Description, "\n", "\n// "),
	)

	fields := make([]*dst.Field, len(ins.Operands))
	for i, operand := range ins.Operands {
		fields[i] = &dst.Field{
			Names: []*dst.Ident{operandIdent(operand)},
			Type:  prettyOperandType(operand),
		}
	}

	return &dst.GenDecl{
		Tok: token.TYPE,
		Specs: []dst.Spec{
			&dst.TypeSpec{
				Name: prettyInstructionIdent(ins),
				Type: &dst.StructType{
					Fields: &dst.FieldList{
						List: fields,
					},
				},
			},
		},
		Decs: dst.GenDeclDecorations{
			NodeDecs: dst.NodeDecs{
				Start: []string{comment},
			},
		},
	}
}

// prettyInstructionConformanceDecl generates the conformance check for PrettyInstruction interface
func prettyInstructionConformanceDecl(ins instruction) *dst.GenDecl {
	return &dst.GenDecl{
		Tok: token.VAR,
		Specs: []dst.Spec{
			&dst.ValueSpec{
				Names: []*dst.Ident{
					dst.NewIdent("_"),
				},
				Type: &dst.Ident{
					Name: "PrettyInstruction",
					Path: opcodePackagePath,
				},
				Values: []dst.Expr{
					&dst.CompositeLit{
						Type: prettyInstructionIdent(ins),
					},
				},
			},
		},
	}
}

// prettyInstructionOpcodeFuncDecl generates the Opcode() method for a pretty instruction
func prettyInstructionOpcodeFuncDecl(ins instruction) *dst.FuncDecl {
	stmt := &dst.ReturnStmt{
		Results: []dst.Expr{
			dst.NewIdent(firstUpper(ins.Name)),
		},
		Decs: dst.ReturnStmtDecorations{
			NodeDecs: dst.NodeDecs{
				Before: dst.NewLine,
				After:  dst.NewLine,
			},
		},
	}
	return &dst.FuncDecl{
		Recv: &dst.FieldList{
			List: []*dst.Field{
				{
					Type: prettyInstructionIdent(ins),
				},
			},
		},
		Name: dst.NewIdent("Opcode"),
		Type: &dst.FuncType{
			Params: &dst.FieldList{},
			Results: &dst.FieldList{
				List: []*dst.Field{
					{
						Type: &dst.Ident{
							Name: "Opcode",
							Path: opcodePackagePath,
						},
					},
				},
			},
		},
		Body: &dst.BlockStmt{
			List: []dst.Stmt{
				stmt,
			},
		},
	}
}

// prettyInstructionStringFuncDecl generates the String() method for a pretty instruction
func prettyInstructionStringFuncDecl(ins instruction) *dst.FuncDecl {
	var stmts []dst.Stmt

	opcodeStringExpr := &dst.CallExpr{
		Fun: &dst.SelectorExpr{
			X: &dst.CallExpr{
				Fun: &dst.SelectorExpr{
					X:   dst.NewIdent("i"),
					Sel: dst.NewIdent("Opcode"),
				},
			},
			Sel: dst.NewIdent("String"),
		},
	}

	if len(ins.Operands) == 0 {
		stmt := &dst.ReturnStmt{
			Results: []dst.Expr{
				opcodeStringExpr,
			},
			Decs: dst.ReturnStmtDecorations{
				NodeDecs: dst.NodeDecs{
					Before: dst.NewLine,
					After:  dst.NewLine,
				},
			},
		}
		stmts = append(stmts, stmt)
	} else {
		stmts = append(
			stmts,
			&dst.DeclStmt{
				Decl: &dst.GenDecl{
					Tok: token.VAR,
					Specs: []dst.Spec{
						&dst.ValueSpec{
							Names: []*dst.Ident{
								dst.NewIdent("sb"),
							},
							Type: &dst.Ident{
								Path: "strings",
								Name: "Builder",
							},
						},
					},
				},
				Decs: dst.DeclStmtDecorations{
					NodeDecs: dst.NodeDecs{
						Before: dst.NewLine,
						After:  dst.NewLine,
					},
				},
			},
		)

		stmts = append(
			stmts,
			&dst.ExprStmt{
				X: &dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X:   dst.NewIdent("sb"),
						Sel: dst.NewIdent("WriteString"),
					},
					Args: []dst.Expr{
						opcodeStringExpr,
					},
				},
			},
		)

		// Generate operand formatting
		for _, operand := range ins.Operands {
			stmts = append(
				stmts,
				&dst.ExprStmt{
					X: &dst.CallExpr{
						Fun: &dst.SelectorExpr{
							X:   dst.NewIdent("sb"),
							Sel: dst.NewIdent("WriteByte"),
						},
						Args: []dst.Expr{
							&dst.BasicLit{
								Kind:  token.CHAR,
								Value: "' '",
							},
						},
					},
				},
			)

			var formatExpr dst.Expr
			operandExpr := &dst.SelectorExpr{
				X:   dst.NewIdent("i"),
				Sel: operandIdent(operand),
			}

			switch operand.Type {
			case operandTypeConstantIndex:
				// printfConstantArgument(sb, "name", constant, false)
				formatExpr = &dst.CallExpr{
					Fun: dst.NewIdent("printfConstantArgument"),
					Args: []dst.Expr{
						&dst.UnaryExpr{
							Op: token.AND,
							X:  dst.NewIdent("sb"),
						},
						&dst.BasicLit{
							Kind:  token.STRING,
							Value: fmt.Sprintf(`"%s"`, operand.Name),
						},
						operandExpr,
						dst.NewIdent("false"),
					},
				}
			case operandTypeTypeIndex:
				// printfTypeArgument(sb, "name", type, false)
				formatExpr = &dst.CallExpr{
					Fun: dst.NewIdent("printfTypeArgument"),
					Args: []dst.Expr{
						&dst.UnaryExpr{
							Op: token.AND,
							X:  dst.NewIdent("sb"),
						},
						&dst.BasicLit{
							Kind:  token.STRING,
							Value: fmt.Sprintf(`"%s"`, operand.Name),
						},
						operandExpr,
						dst.NewIdent("false"),
					},
				}
			case operandTypeTypeIndices:
				// For []StaticType, we need a custom formatter
				formatExpr = &dst.CallExpr{
					Fun: dst.NewIdent("printfPrettyTypeArrayArgument"),
					Args: []dst.Expr{
						&dst.UnaryExpr{
							Op: token.AND,
							X:  dst.NewIdent("sb"),
						},
						&dst.BasicLit{
							Kind:  token.STRING,
							Value: fmt.Sprintf(`"%s"`, operand.Name),
						},
						operandExpr,
						dst.NewIdent("false"),
					},
				}
			case operandTypeUpvalues:
				formatExpr = &dst.CallExpr{
					Fun: dst.NewIdent("printfUpvalueArrayArgument"),
					Args: []dst.Expr{
						&dst.UnaryExpr{
							Op: token.AND,
							X:  dst.NewIdent("sb"),
						},
						&dst.BasicLit{
							Kind:  token.STRING,
							Value: fmt.Sprintf(`"%s"`, operand.Name),
						},
						operandExpr,
						dst.NewIdent("false"),
					},
				}
			default:
				formatExpr = &dst.CallExpr{
					Fun: dst.NewIdent("printfArgument"),
					Args: []dst.Expr{
						&dst.UnaryExpr{
							Op: token.AND,
							X:  dst.NewIdent("sb"),
						},
						&dst.BasicLit{
							Kind:  token.STRING,
							Value: fmt.Sprintf(`"%s"`, operand.Name),
						},
						operandExpr,
						dst.NewIdent("false"),
					},
				}
			}

			stmts = append(stmts, &dst.ExprStmt{X: formatExpr})
		}

		stmts = append(
			stmts,
			&dst.ReturnStmt{
				Results: []dst.Expr{
					&dst.CallExpr{
						Fun: &dst.SelectorExpr{
							X:   dst.NewIdent("sb"),
							Sel: dst.NewIdent("String"),
						},
					},
				},
				Decs: dst.ReturnStmtDecorations{
					NodeDecs: dst.NodeDecs{
						Before: dst.NewLine,
						After:  dst.NewLine,
					},
				},
			},
		)
	}

	return &dst.FuncDecl{
		Recv: &dst.FieldList{
			List: []*dst.Field{
				{
					Names: []*dst.Ident{
						dst.NewIdent("i"),
					},
					Type: prettyInstructionIdent(ins),
				},
			},
		},
		Name: dst.NewIdent("String"),
		Type: &dst.FuncType{
			Params: &dst.FieldList{},
			Results: &dst.FieldList{
				List: []*dst.Field{
					{
						Type: dst.NewIdent("string"),
					},
				},
			},
		},
		Body: &dst.BlockStmt{
			List: stmts,
		},
	}
}

// instructionPrettyMethodDecl generates the Pretty() method on the regular instruction
func instructionPrettyMethodDecl(ins instruction) *dst.FuncDecl {
	var stmts []dst.Stmt

	// Build the composite literal for the pretty instruction
	var fields []*dst.KeyValueExpr
	for _, operand := range ins.Operands {
		var valueExpr dst.Expr
		operandFieldExpr := &dst.SelectorExpr{
			X:   dst.NewIdent("i"),
			Sel: operandIdent(operand),
		}

		switch operand.Type {
		case operandTypeConstantIndex:
			// program.GetConstants()[i.FieldName]
			valueExpr = &dst.IndexExpr{
				X: &dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X:   dst.NewIdent("program"),
						Sel: dst.NewIdent("GetConstants"),
					},
				},
				Index: operandFieldExpr,
			}
		case operandTypeTypeIndex:
			// program.GetTypes()[i.Type]
			valueExpr = &dst.IndexExpr{
				X: &dst.CallExpr{
					Fun: &dst.SelectorExpr{
						X:   dst.NewIdent("program"),
						Sel: dst.NewIdent("GetTypes"),
					},
				},
				Index: operandFieldExpr,
			}
		case operandTypeTypeIndices:
			// Convert []uint16 to []StaticType
			// Create a helper call that maps over the array
			valueExpr = &dst.CallExpr{
				Fun: dst.NewIdent("resolveTypeIndices"),
				Args: []dst.Expr{
					operandFieldExpr,
					&dst.CallExpr{
						Fun: &dst.SelectorExpr{
							X:   dst.NewIdent("program"),
							Sel: dst.NewIdent("GetTypes"),
						},
					},
				},
			}
		default:
			// No resolution needed, just copy the field
			valueExpr = operandFieldExpr
		}

		field := &dst.KeyValueExpr{
			Key:   operandIdent(operand),
			Value: valueExpr,
		}

		field.Decorations().Before = dst.NewLine
		field.Decorations().After = dst.NewLine

		fields = append(fields, field)
	}

	returnStmt := &dst.ReturnStmt{
		Results: []dst.Expr{
			&dst.CompositeLit{
				Type: prettyInstructionIdent(ins),
				Elts: func() []dst.Expr {
					result := make([]dst.Expr, len(fields))
					for i, field := range fields {
						result[i] = field
					}
					return result
				}(),
			},
		},
		Decs: dst.ReturnStmtDecorations{
			NodeDecs: dst.NodeDecs{
				Before: dst.NewLine,
				After:  dst.NewLine,
			},
		},
	}

	stmts = append(stmts, returnStmt)

	return &dst.FuncDecl{
		Recv: &dst.FieldList{
			List: []*dst.Field{
				{
					Names: []*dst.Ident{
						dst.NewIdent("i"),
					},
					Type: instructionIdent(ins),
				},
			},
		},
		Name: dst.NewIdent("Pretty"),
		Type: &dst.FuncType{
			Params: &dst.FieldList{
				List: []*dst.Field{
					{
						Names: []*dst.Ident{
							dst.NewIdent("program"),
						},
						Type: &dst.Ident{
							Name: "ProgramForInstructions",
							Path: opcodePackagePath,
						},
					},
				},
			},
			Results: &dst.FieldList{
				List: []*dst.Field{
					{
						Type: &dst.Ident{
							Name: "PrettyInstruction",
							Path: opcodePackagePath,
						},
					},
				},
			},
		},
		Body: &dst.BlockStmt{
			List: stmts,
		},
	}
}

func writeGoFile(writer io.Writer, decls []dst.Decl, packagePath string) {
	resolver := guess.New()
	restorer := decorator.NewRestorerWithImports(packagePath, resolver)

	packageName, err := resolver.ResolvePackage(packagePath)
	if err != nil {
		panic(err)
	}

	for _, decl := range decls {
		decl.Decorations().Before = dst.NewLine
		decl.Decorations().After = dst.EmptyLine
	}

	err = restorer.Fprint(
		writer,
		&dst.File{
			Name:  dst.NewIdent(packageName),
			Decls: decls,
		},
	)
	if err != nil {
		panic(err)
	}
}

func firstUpper(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToUpper(r)) + s[n:]
}
