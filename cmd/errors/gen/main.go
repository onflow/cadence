/*
 * Cadence - The resource-oriented smart contract programming language
 *
 * Copyright Flow Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"go/token"
	"go/types"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/decorator/resolver/guess"
	"golang.org/x/tools/go/packages"
)

const header = `// Code generated by main.go. DO NOT EDIT.

`

// NOTE: must be formatted/injected , as otherwise
// it will be detected itself as a go generate invocation itself
const goGenerateComment = "//go:generate go run ./gen errors.go\n\n"

func main() {

	if len(os.Args) != 2 {
		log.Fatalf("Usage: %s <file>", os.Args[0])
	}

	target := os.Args[1]

	pkgs, err := packages.Load(
		&packages.Config{
			Mode: packages.NeedImports | packages.NeedTypes,
		},
		"github.com/onflow/cadence/parser",
		"github.com/onflow/cadence/sema",
	)
	if err != nil {
		log.Fatalf("Failed to load packages: %v", err)
	}

	parserPkg, semaPkg := pkgs[0], pkgs[1]

	var errors []dst.Expr

	// Get the 'parser.ParseError' interface type
	parserPkgScope := parserPkg.Types.Scope()
	parseErrorType := parserPkgScope.Lookup("ParseError").Type().Underlying().(*types.Interface)
	errors = append(
		errors,
		namedErrorElements(
			parserPkg,
			parserPkgScope,
			parseErrorType,
		)...,
	)

	// Get the 'sema.SemanticError' interface type
	semaPkgScope := semaPkg.Types.Scope()
	semanticErrorType := semaPkgScope.Lookup("SemanticError").Type().Underlying().(*types.Interface)
	errors = append(
		errors,
		namedErrorElements(
			semaPkg,
			semaPkgScope,
			semanticErrorType,
		)...,
	)

	funcDecl := &dst.FuncDecl{
		Name: dst.NewIdent("generateErrors"),
		Type: &dst.FuncType{
			Results: &dst.FieldList{
				List: []*dst.Field{
					{
						Type: &dst.ArrayType{
							Elt: dst.NewIdent("namedError"),
						},
					},
				},
			},
		},
		Body: &dst.BlockStmt{
			List: []dst.Stmt{
				&dst.ReturnStmt{
					Results: []dst.Expr{
						&dst.CompositeLit{
							Type: &dst.ArrayType{
								Elt: dst.NewIdent("namedError"),
							},
							Elts: errors,
						},
					},
				},
			},
		},
	}

	f, err := os.Create(target)
	if err != nil {
		log.Fatalf("Failed to open error file: %v", err)
	}
	defer f.Close()

	_, err = f.WriteString(header)
	if err != nil {
		log.Fatalf("Failed to write header: %v", err)
	}

	_, err = f.WriteString(goGenerateComment)
	if err != nil {
		log.Fatalf("Failed to write header: %v", err)
	}

	writeGoFile(
		f,
		[]dst.Decl{funcDecl},
		"main",
	)
}

func namedErrorElements(
	pkg *packages.Package,
	scope *types.Scope,
	errorType *types.Interface,
) []dst.Expr {

	var elements []dst.Expr

	for _, name := range scope.Names() {
		object := scope.Lookup(name)

		var isPointer bool
		ty := object.Type()
		if !types.Implements(ty, errorType) {
			ty = types.NewPointer(ty)
			isPointer = true
			if !types.Implements(ty, errorType) {
				continue
			}
		}

		structType, ok := object.Type().Underlying().(*types.Struct)
		if !ok {
			continue
		}

		elements = append(
			elements,
			namedErrorElement(
				pkg,
				object,
				structType,
				isPointer,
			),
		)
	}

	return elements
}

func namedErrorElement(
	pkg *packages.Package,
	object types.Object,
	structType *types.Struct,
	isPointer bool,
) dst.Expr {

	composite := &dst.CompositeLit{
		Type: &dst.Ident{
			Name: object.Name(),
			Path: pkg.ID,
		},
	}

	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		composite.Elts = append(
			composite.Elts,
			goKeyValue(
				field.Name(),
				placeholderValue(field.Type()),
			),
		)
	}

	var value dst.Expr = composite
	if isPointer {
		value = &dst.UnaryExpr{
			Op: token.AND,
			X:  value,
		}
	}

	value.Decorations().Before = dst.NewLine
	value.Decorations().After = dst.NewLine

	typeName := object.Type().String()

	element := &dst.CompositeLit{
		Elts: []dst.Expr{
			&dst.BasicLit{
				Kind:  token.STRING,
				Value: strconv.Quote(filepath.Base(typeName)),
			},
			value,
		},
	}

	element.Decorations().Before = dst.NewLine
	element.Decorations().After = dst.NewLine

	return element
}

func placeholderValue(t types.Type) dst.Expr {
	switch t.String() {
	case "string":
		return dst.NewIdent("placeholderString")

	case "[]string":
		return dst.NewIdent("placeholderStrings")

	case "int64", "int", "uint":
		return dst.NewIdent("placeholderInt")

	case "bool":
		return dst.NewIdent("false")

	case "error":
		return dst.NewIdent("placeholderError")

	case "*math/big.Int":
		return dst.NewIdent("placeholderBigInt")

	case "github.com/onflow/cadence/ast.Position":
		return dst.NewIdent("placeholderPosition")

	case "*github.com/onflow/cadence/ast.Position":
		return &dst.UnaryExpr{
			Op: token.AND,
			X:  dst.NewIdent("placeholderPosition"),
		}

	case "github.com/onflow/cadence/ast.Range":
		return dst.NewIdent("placeholderRange")

	case "github.com/onflow/cadence/common.IntegerLiteralKind":
		return dst.NewIdent("placeholderIntegerLiteralKind")

	case "github.com/onflow/cadence/parser.InvalidNumberLiteralKind":
		return dst.NewIdent("placeholderInvalidNumberLiteralKind")

	case "github.com/onflow/cadence/common.CompositeKind":
		return dst.NewIdent("placeholderCompositeKind")

	case "github.com/onflow/cadence/sema.Type":
		return dst.NewIdent("placeholderSemaType")

	case "github.com/onflow/cadence/ast.Access":
		return dst.NewIdent("placeholderAstAccess")

	case "github.com/onflow/cadence/ast.Expression":
		return dst.NewIdent("placeholderExpression")

	case "github.com/onflow/cadence/ast.CompositeLikeDeclaration":
		return dst.NewIdent("placeholderCompositeLikeDeclaration")

	case "*github.com/onflow/cadence/sema.CompositeType":
		return dst.NewIdent("placeholderCompositeType")

	case "*github.com/onflow/cadence/sema.InterfaceType":
		return dst.NewIdent("placeholderInterfaceType")

	case "*github.com/onflow/cadence/sema.InitializerMismatch":
		return dst.NewIdent("placeholderInitializerMismatch")

	case "[]*github.com/onflow/cadence/sema.Member":
		return dst.NewIdent("placeholderMembers")

	case "[]github.com/onflow/cadence/sema.MemberMismatch":
		return dst.NewIdent("placeholderMemberMismatches")

	case "[]*github.com/onflow/cadence/sema.CompositeType":
		return dst.NewIdent("placeholderCompositeTypes")

	case "github.com/onflow/cadence/common.ControlStatement":
		return dst.NewIdent("placeholderControlStatement")

	case "*github.com/onflow/cadence/sema.EntitlementMapType":
		return dst.NewIdent("placeholderEntitlementMapType")

	case "github.com/onflow/cadence/common.Location":
		return dst.NewIdent("placeholderLocation")

	case "github.com/onflow/cadence/common.DeclarationKind":
		return dst.NewIdent("placeholderDeclarationKind")

	case "github.com/onflow/cadence/sema.DefaultDestroyInvalidArgumentKind":
		return dst.NewIdent("placeholderDefaultDestroyInvalidArgumentKind")

	case "github.com/onflow/cadence/sema.CompositeKindedType":
		return dst.NewIdent("placeholderCompositeKindedType")

	case "github.com/onflow/cadence/ast.TransferOperation":
		return dst.NewIdent("placeholderTransferOperation")

	case "*github.com/onflow/cadence/ast.NominalType":
		return dst.NewIdent("placeholderNominalType")

	case "*github.com/onflow/cadence/sema.EntitlementType":
		return dst.NewIdent("placeholderEntitlementType")

	case "github.com/onflow/cadence/sema.ResourceInvalidationKind":
		return dst.NewIdent("placeholderResourceInvalidationKind")

	case "github.com/onflow/cadence/common.OperandSide":
		return dst.NewIdent("placeholderOperandSide")

	case "github.com/onflow/cadence/ast.Operation":
		return dst.NewIdent("placeholderOperation")

	case "github.com/onflow/cadence/ast.VariableKind":
		return dst.NewIdent("placeholderVariableKind")

	case "*github.com/onflow/cadence/sema.Member":
		return dst.NewIdent("placeholderMember")

	case "*github.com/onflow/cadence/sema.ReferenceType":
		return dst.NewIdent("placeholderReferenceType")

	case "*github.com/onflow/cadence/ast.IdentifierExpression":
		return dst.NewIdent("placeholderIdentifierExpression")

	case "*github.com/onflow/cadence/ast.MemberExpression":
		return dst.NewIdent("placeholderMemberExpression")

	case "*github.com/onflow/cadence/sema.OptionalType":
		return dst.NewIdent("placeholderOptionalType")

	case "github.com/onflow/cadence/sema.ResourceInvalidation":
		return dst.NewIdent("placeholderResourceInvalidation")

	case "github.com/onflow/cadence/ast.Declaration":
		return dst.NewIdent("placeholderDeclaration")

	case "*github.com/onflow/cadence/ast.Identifier":
		return dst.NewIdent("placeholderIdentifierPointer")

	case "*github.com/onflow/cadence/sema.TypeParameter":
		return dst.NewIdent("placeholderTypeParameter")

	case "[2]github.com/onflow/cadence/sema.Access":
		return dst.NewIdent("placeholderTwoSemaAccessArray")

	case "github.com/onflow/cadence/sema.Access":
		return dst.NewIdent("placeholderSemaAccess")

	case "github.com/onflow/cadence/ast.Type":
		return dst.NewIdent("placeholderAstType")

	case "github.com/onflow/cadence/sema.EntitlementSetAccess":
		return dst.NewIdent("placeholderEntitlementSetAccess")

	case "github.com/onflow/cadence/parser/lexer.TokenType":
		return dst.NewIdent("placeholderTokenType")

	case "github.com/onflow/cadence/parser/lexer.Token":
		return dst.NewIdent("placeholderToken")

	case "github.com/onflow/cadence/ast.Identifier":
		return dst.NewIdent("placeholderIdentifier")

	default:
		log.Fatalf("unsupported field type: %s", t.String())
		return nil
	}
}

func writeGoFile(writer io.Writer, decls []dst.Decl, packagePath string) {
	resolver := guess.New()
	restorer := decorator.NewRestorerWithImports(packagePath, resolver)

	packageName, err := resolver.ResolvePackage(packagePath)
	if err != nil {
		panic(err)
	}

	for _, decl := range decls {
		decl.Decorations().Before = dst.NewLine
		decl.Decorations().After = dst.EmptyLine
	}

	err = restorer.Fprint(
		writer,
		&dst.File{
			Name:  dst.NewIdent(packageName),
			Decls: decls,
		},
	)
	if err != nil {
		panic(err)
	}
}

func goKeyValue(name string, value dst.Expr) *dst.KeyValueExpr {
	expr := &dst.KeyValueExpr{
		Key:   dst.NewIdent(name),
		Value: value,
	}
	expr.Decorations().Before = dst.NewLine
	expr.Decorations().After = dst.NewLine
	return expr
}
